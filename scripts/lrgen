#!/bin/bash
# Copyright (c) 2023, 2024 Logic Magicians Software
#
# BSD 3 License
#
#set -o nounset;
set -o pipefail;
set -o errexit;

SCRIPT="${BASH_SOURCE[0]}"
SRC_DIR=$(dirname "${SCRIPT}");
if [ ! -z "${LRSTAR_DIR}" ]; then
    # Development environment being used.
    # Resolve LRSTAR and DFA with developmental shell functions.
    source $(readlink -f "${LRSTAR_DIR}/scripts/functions");
fi;

LRSTAR="${LRSTAR:-lrstar}";
DFA="${DFA:-dfa}";
DIRECTORY="";
GRM="";
GRMOPT="";
LGROPT="";


function _help()
{
    cat <<EOF

lrgen (-d <directory> | --directory) <directory>  |
      [(-g | --grm) <grm-name>                    |
       (-G | --grmopt) <lrstar options>           |
       (-L | --lgropt) <dfa options>]

Details:

  This tool is a wrapper for invoking both lrstar on a syntax grammar
  & dfa on a lexcical grammar.  The syntax grammar must exist, but the
  lexical grammar is not required.

  If the lexical grammar is not supplied, then the user is responsible
  for creating a tokenizer that returns token identifier values as
  specified by lrstar in <grm-name>.lex file.

  Both the syntax and lexcial grammars must reside in the same
  directory.  The files generated by lrstar and dfa will be placed
  into the same directory as the grammar files.

  The files generated by lrstar and dfa will be placed into the
  directory supplied for '--directory'.

  -d | --directory  (required)

    This is used to specify the directory that contains the 'grm' and,
    optionally, the 'lgr' grammars.

  -g | --grm         (optional)

    This specifies the name of both the syntax grammar ('grm') and
    lexical grammar ('lgr') files.  If not specified, the final
    component of the '--directory' value will be used.

  -G | --grmopt      (optional)

    This facilitates providing options to the invocation of lrstar for
    the specified grammar.

  -L | --lgropt      (optional)

    This facilitates providing options to the invocation of dfa for
    the specified grammar.


Environment:

  This tool uses two environment variables -- LRSTAR & DFA -- to
  execute 'lrstar' and 'dfa' respectively.

  LRSTAR:

    The default value of this variable is 'lrstar'.  If a development
    environment is being used in the current shell, this will resolve
    to the shell function 'lrstar', and that will refer to the version
    built from the source tree.

    If a developemnt environment is not being used, it will resolve to
    an on-disk file that must be in the path.  If lrstar is not in the
    path, either ensure it is in the path, or set LRSTAR to the full
    path of the lrstar executable.

  DFA

    The default value of this variable is 'dfa'.  If a development
    environment is being used in the current shell, this will resolve
    to the shell function 'dfa', and that will refer to the version
    built from the source tree.

    If a developemnt environment is not being used, it will resolve to
    an on-disk file that must be in the path.  If dfa is not in the
    path, either ensure it is in the path, or set DFA to the full
    path of the dfa executable.


Examples:

  lrgen --directory ${LRSTAR_DIR}/grammars/C11 -grm C11
  lrgen -d ${LRSTAR_DIR}/grammars/C11

    Generate tables for syntax & lexical grammars of C11.


  lrgen -d ${LRSTAR_DIR}/examples/LRK --grmopt "k=100 st d"

    Generate tables for syntax and lexical grammars of LR(*)
    parsing example.


  lrgen -d ${LRSTAR_DIR}/grammars/ALGOL60 -G "ast o"

    Generate tables for syntax grammar of ALGOL60.
    There is no lexical grammar provided for this grammar.


EOF
}


function fatal ()
{
    local msg="${1}";

    echo -e "fatal: ${msg}\n\n";
    exit 1;
}


# Produce an absolute pathname of the 'grm' file.
#
#  lrstar does not properly deal with full pathnames on the command
#  line; it uses the full pathname rather than just the grammar name.
#  Be sure to extract only the basename when used with lrstar.
#
function grm_filename ()
{
    local directory="${1}";
    local grm_name="${2}";

    echo "${directory}/${grm_name}.grm";
}


# Produce an absolute pathname of the 'lgr' file.
#
#  dra does not properly deal with full pathnames on the command line;
#  it uses the full pathname rather than just the grammar name.  Be
#  sure to extract only the basename when used with dfa.
#
function lgr_filename ()
{
    local directory="${1}";
    local grm_name="${2}";

    echo "${directory}/${grm_name}.lgr";
}


function validate_options()
{
    local grm;

    DIRECTORY=$(readlink -f "${DIRECTORY}");
    if [ -z "${DIRECTORY}" ] ; then
        _help;
        echo -e "\n";
        fatal "Directory holding grammar files must be specified.";
    elif [ ! -d "${DIRECTORY}" ] ; then
        fatal "--directory value, '${DIRECTORY}', is not a directory.";
    fi;

    # invariant:
    #
    #   ${DIRECTORY} is the absolute pathname of the directory
    #   supplied on the command line.

    if [ -z "${GRM}" ] ; then
        # Infer grammar name from directory name.
        #
        # If the grammar name has not been supplied, assume it is the
        # same as the directory name.
        #
        GRM=$(basename "${DIRECTORY}");
    fi;


    grm=$(grm_filename "${DIRECTORY}" "${GRM}");
    if [ ! -r "${grm}" ] ; then
        fatal "'${grm}' is not a readable file.";
    fi;

    # Validate that lrstar and dfa are both executable.
    if ! (${LRSTAR} 2>&1) >/dev/null; then
        fatal "${LRSTAR} not found.  See --help.\n";
    fi;

    if ! (${DFA} 2>&1) >/dev/null; then
        fatal "${DFA} not found.  See --help.\n";
    fi;
}


function process_grammars()
{
    local grm=$(basename $(grm_filename "${DIRECTORY}" "${GRM}"));
    local lgr=$(basename $(lgr_filename "${DIRECTORY}" "${GRM}"));

    if ${LRSTAR} "${grm}" ${GRMOPT}; then
        # LRSTAR has run successfully.  Next, run DFA if a lexical
        # grammar exists.
        if [ -r "${lgr}" ] ; then
            local dfa=""
            if ! ${DFA} ${lgr} ${LGROPT}; then
                fatal "'${DFA} ${lgr} ${LGROPT}' failed.";
            fi;
        fi;
    else
        fatal "'${LRSTAR} "${grm}" ${GRMOPT}' failed.";
    fi;
}


function create_makefile ()
{
    local makefile="${GRM}.make";

    if [ -e "${makefile}" ] ; then
        return;
    fi;

    cat >${makefile} <<EOF
# This Makefile is generated by lrgen.
# lrgen will NOT overwrite this Makefile.
#
#
# This Makefile will build the '${GRM}' parser sample program.
#
# It should be invoked like this when using a DEVELOPMENT tree of
# lrstar:
#
#  make                                      \\
#     LRSTAR_BOD=<bod>                       \\
#     LRSTAR_INSTALL_ROOT=<lrstar-directory> \\
#     -f $(readlink -f ./${GRM}.make)
#
#
# It should be invoked like this when using an INSTALLED lrstar:
#
#  make                                      \\
#     LRSTAR_BOD=<bod>                       \\
#     -f $(readlink -f ./${GRM}.make)
#
#
#  <bod>:
#
#   This is the 'build output directory'.  It should be the full
#   pathname where the artifacts should be placed by the build
#   process.
#
#   The <bod> should not be placed into the source directory.
#   A good location is "/tmp/\${GRM}".
#
#  <lrstar-directory>:
#
#   This it the directory to which lrstar has been installed.
#
#   When using an lrstar development tree, the value should be:
#
#     LRSTAR_INSTALL_ROOT=\${LRSTAR_BUILD_DIR}/\${LRSTAR_BUILD_TYPE}/usr/local
#
#   If using an installed version of lrstar, it should be:
#
#     LRSTAR_INSTALL_ROOT=/usr/local
#
# Example (development lrstar):
#
#  make \\
#     LRSTAR_BOD=/tmp/${GRM} \\
#     LRSTAR_INSTALL_ROOT=\${LRSTAR_BUILD_DIR}/\${LRSTAR_BUILD_TYPE}/usr/local
#     -f \$(readlink -f ./\${GRM}.make)
#
#
# Example (installed lrstar):
#
#  make \\
#     LRSTAR_BOD=/tmp/${GRM} \\
#     -f \$(readlink -f ./\${GRM}.make)
#
#
# The resultant executable, having the 'basename' of the grammar,
# will be placed into a subdirectory of:
#
#  \${LRSTAR_BOD}
#
GRM		:= ${GRM}
${GRM}_GRMOPT	:= ${GRMOPT}
${GRM}_LGROPT	:= ${LGROPT}

.DEFAULT_GOAL	:= recurse	# In sample.defs


# A development environment has files in \$(LRSTAR_INSTALL_ROOT), post build.
# For a non-development environment, files should be installed in /usr/local.
#
INSTALL_ROOT	:=			\\
	\$(if \$(LRSTAR_INSTALL_ROOT),\$(LRSTAR_INSTALL_ROOT),/usr/local)


include \$(INSTALL_ROOT)/make/sample.defs

# Create a list of source files for each listed grammar.  Only the
# first-listed grammar's main() is included.
#
\$(foreach g,\$(GRM),				\\
    \$(eval \$(g)_SOURCE=\$(g)_Lexer.cpp		\\
	\$(g)_Main.cpp				\\
	\$(g)_Parser.cpp				\\
	\$(g)_user.cpp))
\$(eval \$(firstword \$(GRM))_SOURCE += \$(firstword \$(GRM))_user_main.cpp)


# Create a list of object files for each included grammar.  The object
# files are dependent on a sentinel file created when running lrgen on
# the grammars; this ensures the source files are recompiled if the
# grammars are changed.
#
\$(foreach g,\$(GRM),				\\
    \$(eval \$(g)_OBJS=\$(\$(g)_SOURCE:.cpp=.o))	\\
    \$(eval \$(\$(g)_OBJS): \$(g).sentinel))


# Use the 'lrgen' function to process the grammars.
#
\$(foreach g,\$(GRM),	\\
    \$(eval \$(call lrgen,\$(GRM_DIR),\$(g),\$(\$(g)_GRMOPT),\$(\$(g)_LGROPT))))


# A master list of all source files that need to be compiled.
#
SOURCE	:=					\\
	\$(foreach g,\$(GRM),\$(\$(g)_SOURCE))


OBJS	:=				\\
	\$(SOURCE:.cpp=.o)		\\
	\$(INSTALL_ROOT)/lib/lrstar.a


# The created executable will have the same name as the first grammar
# in \$(GRM).
#
\$(firstword \$(GRM)):	\$(OBJS)
	\$(CC) \$(CXXFLAGS) -o \$@ \$(OBJS);


clean:
	rm \$(OBJS) \$(GRM);

-include \$(SOURCE:.cpp=.d)
EOF
}



function main()
{
    validate_options;
    if cd "${DIRECTORY}" 2>/dev/null; then
        process_grammars;
        create_makefile;
    else
        fatal "Cannot change to '${DIRECTORY}'.";
    fi;
}

args=$(/usr/bin/getopt -o hd:g:G:L:                                                     \
                       -n "lrgen"                                                       \
                       --longoptions help,directory:,grm:,grmopt:,lgropt: -- "${@}")

if [ $? != 0 ] ; then
    fatal "Failure processing command line arguments";
fi;

eval set -- "$args";            # Set postional args to ${args}.
unset args;

while true ; do
    case "$1" in
        -h|--help)
            _help;
            exit 0;
            ;;

        -d|--directory)
            if [ -z "${DIRECTORY}" ] ; then
                DIRECTORY=${2};
            else
                fatal "--directory already specified.";
            fi;
            shift 2;
            ;;

        -g|--grm)
            if [ -z "${GRM}" ] ; then
                GRM=${2};
            else
                fatal "--grm already specified.";
            fi;

            shift 2;
            ;;

        -G|--grmopt)
            if [ -z "${GRMOPT}" ] ; then
                GRMOPT=$(eval echo ${2});
            else
                fatal "--grmopt already specified.";
            fi;
            shift 2;
            ;;

        -L|--lgropt)
            if [ -z "${LGROPT}" ] ; then
                LGROPT=$(eval echo ${2});
            else
                fatal "--lgropt already specified.";
            fi;
            shift 2;
            ;;

        --)                 # End of arguments
            shift;
            break;
            ;;

        *)
            fatal "Unknown option '${1}'";
            ;;
    esac
done;

main ${@};
