#!/bin/bash
#
# Copyright (c) 2023, 2024 Logic Magicians Software
#
#  This script is used to ensure that the lrstar and dfa program do
#  not generate different output than a previous version.
#
#  The text log files that are output by lrstar and dfa include memory
#  utilization and execution time.  These will vary from run-to-run.
#  It is up to the user of this tool to ensure that the times & memory
#  utilization have not gotten worse in an unjustifiable way.
#
# BSD 3 License
#
set -o errexit;
set -o nounset;
set -o pipefail;

SCRIPT="${0}";
PN=${SCRIPT##*/};      # Program name (remove all before last '/').
DN=${SCRIPT%/*};       # Directory name (removall all after last '/').

# This is used to declare the name of the grammar(s) when there are
# multiple grammars, or the grammar name does not match the directory
# name.
#
declare -A grammars=(
    ["multi"]="Hello Goodbye"
);


declare -A test_options=(
    ["multi"]="--hello hello.input --goodbye goodbye.input"
);


function fatal ()
{
    local msg="${1}";
    echo "fatal: ${msg}";
    exit 1;
}


function lrgen ()
{
    declare -A lrstar_options=(
        ["ALGOL60"]="ast o"
        ["ANTLR"]=""
        ["Ada"]="ci m"
        ["C"]="o !ta !na !ast !exp"
        ["C11"]="k=10"
        ["CICS"]=""
        ["COBOL"]=""
        ["CPP5"]="/st"
        ["Calc"]="d dt"
        ["Dbase"]=""
        ["Fortran"]=""
        ["JSON"]="ast astp=3 d"
        ["Java1"]=""
        ["Java9"]="/k=30"
        ["Kotlin"]=""
        ["LRK"]="k=100 st d"
        ["Modula2"]=""
        ["NCSA"]="st g"
        ["PL1"]="o"
        ["PLM"]=""
        ["PLSQL"]="m"
        ["Pascal"]="ci"
        ["Python"]="/k=3 /st"
        ["SQL"]=""
        ["Typedef"]="d st"
        ["Vba"]=""
        ["XPL"]=""
        ["YACC"]=""
        ["Zeus"]=""
        ["delphi"]="ci"
        ["multi"]="d m"
        ["verilog"]=""
    );

    declare -A dfa_options=(
        ["ALGOL60"]=""
        ["ANTLR"]=""
        ["Ada"]=""
        ["C"]="m"
        ["C11"]=""
        ["CICS"]=""
        ["COBOL"]=""
        ["CPP5"]=""
        ["Calc"]=""
        ["Dbase"]=""
        ["Fortran"]=""
        ["JSON"]=""
        ["Java1"]=""
        ["Java9"]="st"
        ["Kotlin"]=""
        ["LRK"]=""
        ["Modula2"]=""
        ["NCSA"]=""
        ["PL1"]=""
        ["PLM"]="sto m"
        ["PLSQL"]="sto m"
        ["Pascal"]=""
        ["Python"]=""
        ["SQL"]=""
        ["Typedef"]=""
        ["Vba"]=""
        ["XPL"]=""
        ["YACC"]=""
        ["Zeus"]=""
        ["delphi"]=""
        ["multi"]=""
        ["verilog"]=""
    );

    local grm_dir="${1}";
    local grm="${2}";
    local grm_name="$(basename "${grm}" ".grm")";

    ${LRSTAR_DIR}/scripts/lrgen                         \
        --directory "${grm_dir}"                        \
        --grm    "${grm}"                               \
        --grmopt "${lrstar_options[${grm_name}]:-''}"   \
        --lgropt "${dfa_options[${grm_name}]:-''}";
}


function build ()
{
    local grm_dir="${1}";
    local grm="${2}";
    local lrstar_dir="${LRSTAR_BUILD_DIR}/${LRSTAR_BUILD_TYPE}"
    local root="${lrstar_dir}/usr/local";
    local bod="${lrstar_dir}${grm_dir//${LRSTAR_DIR}}";

    rm -f "${grm_dir}/*.o";
    make                                        \
        -C "${grm_dir}"                         \
        --makefile ${grm_dir}/${grm}.make       \
        LRSTAR_BOD="${bod}"                     \
        LRSTAR_INSTALL_ROOT=${root}
 }


function lrgen_and_build ()
{
    local grm_dir="${1}";
    local grm_name="$(basename "${grm_dir}")";
    local grms=( ${grammars[${grm_name}]:-${grm_name}} );
    local grammar_count=${#grms[@]};
    local grammar;

    for grammar in ${grms[@]}; do
        local grm="${grm_dir}/${grammar}.grm";
        local lgr="${grm_dir}/${grammar}.lgr";

        if [ -r "${grm}" ] ; then
            lrgen "${grm_dir}" "${grammar}";
        else
            echo "${grm} does not exist";
        fi;

        if [ ${grammar_count} == 1 ] ; then
            if [ -r "${lgr}" ] ; then
                # The lexical grammar exists, the project should build
                # into an executable with the generated Makefile.
                build "${grm_dir}" "${grammar}";
            fi;
        else
            # Multiple grammars.  Build the first grammar, assuming it
            # is the one modified to include the second grammar in the
            # build process.
            #
            build "${grm_dir}" "${grms[0]}";
        fi;
    done;
}


function cleanup ()
{
    # Remove all generated files.
    local grm_dir="${1}";
    rm -f                                       \
       ${grm_dir}/*.o                           \
       ${grm_dir}/$(basename "${grm_dir}");
}


function test_grammar ()
{
    local grm="${1}";
    local grm_name="${2}";
    local options="${3}";

    (cd ${grm};
     grm_build_dir="${LRSTAR_BUILD_DIR}/${LRSTAR_BUILD_TYPE}/${grm##${LRSTAR_DIR}/}";
     grm_exec="${grm_build_dir}/${grm_name}";
     grm_output="${grm_build_dir}/${grm_name}-output.text";

     rc=0;
     if [ -x "${grm_exec}" ] ; then
         if [ -z "${options}" ] ; then
             if ! "${grm_exec}" --output ${grm_output} test.input.txt; then
                 rc=1;
                 echo "${grm}: test parse failed.";
             fi;
         else
             if ! "${grm_exec}" --output ${grm_output} ${options}; then
                 rc=1;
                 echo "${grm}: test parse failed.";
             fi;
         fi;
         exit ${rc};
     else
         echo "${grm_exec} does not exist.  Cannot run test.";
         exit 1;
     fi);
}


function main ()
{
    export LANG=C;              # Make gcc not use UTF-8.

    if [ -v LRSTAR_DIR ] ; then
        local grammar="${LRSTAR_DIR}/grammars";
        local example="${LRSTAR_DIR}/examples";
        local grm_name;

        cd ${LRSTAR_DIR};
        for grm in ${grammar}/* ${example}/*; do
            # The Kotlin lexical grammar is not a dfa grammar, so skip
            # testing until that can be sorted out.
            if [ "$(basename ${grm})" != "Kotlin" ] ; then
                # Pre-cleanup in case last build & test failed.
                #
                # Note that lrstar / dfa cannot be easily run from the
                # build directory via usage of VPATH.  This is true
                # because they write the output into the same place as
                # in the input file.  And lrstar doesn't properly
                # handle the input grammar pathname, incorrectly using
                # the full path.
                #
                # Bottom line, until path handling is improved, ony
                # execute lrstar while the CWD is directory containing
                # the grammar file.
                cleanup "${grm}";
                lrgen_and_build "${grm}";

                # Java1 and Java9 test files do not parse
                # correctly.  They are both identical, so
                # I suspect that they both cannot be
                # correct.
                #
                # Similarly, the LRK grammar fails with the default
                # 'k=<val>'.  Up to at least k=5 fails; so skip it.
                #
                grm_name=$(basename "${grm}");
                if [ "${grm_name}" != "Java1" ] &&
                   [ "${grm_name}" != "Java9" ] &&
                   [ "${grm_name}" != "LRK" ]; then

                    # If there is a test.input.txt file in the
                    # directory, the grammar will have been compiled
                    # into an executable for testing.
                    #
                    if [ -r "${grm}/test.input.txt" ] ; then
                        test_grammar "${grm}" "${grm_name}" "";
                    else
                        # There is no test.input.txt.  It is a grammar
                        # that has not been built into an executable,
                        # or a different test invocation must be used.
                        # The invocation for such grammars is stored
                        # in 'test_options'.
                        #
                        local options="${test_options[${grm_name}]:-""}";
                        if [ ! -z "${options}" ] ; then
                            local grms=( ${grammars[${grm_name}]:-${grm_name}} );
                            local gname="${grms[0]}";
                            test_grammar "${grm}" "${gname}" "${options}";
                        fi;
                    fi;
                fi;

                cleanup "${grm}";
            fi;
        done;
    else
        echo "LRSTAR environment is not set up.";
        false;
    fi;
}

main "${@}";
