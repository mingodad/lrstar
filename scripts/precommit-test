#!/bin/bash
#
# Copyright (c) 2023 Logic Magicians Software
#
#  This script is used to ensure that the lrstar and dfa program do
#  not generate different output than a previous version.
#
#  The text log files that are output by lrstar and dfa include memory
#  utilization and execution time.  These will vary from run-to-run.
#  It is up to the user of this tool to ensure that the times & memory
#  utilization have not gotten worse in an unjustifiable way.
#
# BSD 3 License
#
set -o errexit;
set -o nounset;
set -o pipefail;

SCRIPT="${0}";
PN=${SCRIPT##*/};      # Program name (remove all before last '/').
DN=${SCRIPT%/*};       # Directory name (removall all after last '/').

function fatal ()
{
    local msg="${1}";
    echo "fatal: ${msg}";
    exit 1;
}


function lrstar ()
{
    local lrstar="$(lrstar-path)";
    local grm="${1}";
    local grm_name="$(basename "${grm}")";
    local grm_dir="$(dirname "${grm}")";
    declare -A options=(
        ["ALGOL60.grm"]="ast o"
        ["ANTLR.grm"]="m"
        ["Ada.grm"]="ci m"
        ["C.grm"]="o ast=0"
        ["C11.grm"]="o"
        ["CICS.grm"]=""
        ["COBOL.grm"]=""
        ["CPP5.grm"]=""
        ["Calc.grm"]=""
        ["Dbase.grm"]=""
        ["Fortran.grm"]=""
        ["JSON.grm"]="ast d"
        ["Java1.grm"]=""
        ["Java9.grm"]=""
        ["Kotlin.grm"]=""
        ["LRK.grm"]="k=100"
        ["Modula2.grm"]=""
        ["NCSA.grm"]=""
        ["PL1.grm"]=""
        ["PLM.grm"]=""
        ["PLSQL.grm"]="m"
        ["Pascal.grm"]="ci"
        ["Python.grm"]=""
        ["SQL.grm"]=""
        ["Typedef.grm"]=""
        ["Vba.grm"]=""
        ["XPL.grm"]=""
        ["YACC.grm"]=""
        ["Zeus.grm"]=""
        ["delphi.grm"]="ci"
        ["verilog.grm"]=""
    );

    pushd "${grm_dir}" >/dev/null;
    "${lrstar}" "${grm_name}" ${options[${grm_name}]};
    popd >/dev/null
}


function dfa ()
{
    local dfa="$(dfa-path)";
    local lgr="${1}";
    local lgr_name="$(basename "${lgr}")";
    local lgr_dir="$(dirname "${lgr}")";
    declare -A options=(
        ["ALGOL60.lgr"]=""
        ["ANTLR.lgr"]="sto m"
        ["Ada.lgr"]=""
        ["C.lgr"]=""
        ["C11.lgr"]=""
        ["CICS.lgr"]=""
        ["COBOL.lgr"]=""
        ["CPP5.lgr"]=""
        ["Calc.lgr"]=""
        ["Dbase.lgr"]=""
        ["Fortran.lgr"]=""
        ["JSON.lgr"]=""
        ["Java1.lgr"]=""
        ["Java9.lgr"]=""
        ["Kotlin.lgr"]=""
        ["LRK.lgr"]="sto"
        ["Modula2.lgr"]=""
        ["NCSA.lgr"]=""
        ["PL1.lgr"]=""
        ["PLM.lgr"]="sto m"
        ["PLSQL.lgr"]="sto m"
        ["Pascal.lgr"]=""
        ["Python.lgr"]=""
        ["SQL.lgr"]=""
        ["Typedef.lgr"]="m"
        ["Vba.lgr"]=""
        ["XPL.lgr"]=""
        ["YACC.lgr"]=""
        ["Zeus.lgr"]=""
        ["delphi.lgr"]=""
        ["verilog.lgr"]=""
    );

    pushd "${lgr_dir}" >/dev/null;
    "${dfa}" "${lgr_name}" ${options[${lgr_name}]};
    popd >/dev/null;
}


function build ()
{
    local grm_dir="${1}";

    rm -f "${grm_dir}/*.o";
    make \
        -C "${grm_dir}" \
        LRSTAR_INSTALL_ROOT=${LRSTAR_BUILD_DIR}/${LRSTAR_BUILD_TYPE}/usr/local
 }

function process ()
{
    local grm_dir="${1}";
    local grm_name="$(basename "${grm_dir}")";
    local grm="${grm_dir}/${grm_name}.grm";
    local lgr="${grm_dir}/${grm_name}.lgr";
    local makefile="${grm_dir}/Makefile"

    if [ -r "${grm}" ] ; then
        lrstar "${grm}";
    else
        echo "${grm} does not exist";
    fi;

    if [ -r "${lgr}" ] ; then
        dfa "${lgr}";
    else
        echo "${lgr} does not exist.";
    fi;

    if [ -r "${lgr}" ] ; then
        # The lexical grammer exists, the project should build into an
        # executable with the generated Makefile.
        build "${grm_dir}";
   fi;
}


function cleanup ()
{
    # Remove all generated files.
    local grm_dir="${1}";
    rm -f                                       \
       ${grm_dir}/*.o                           \
       ${grm_dir}/$(basename "${grm_dir}");
}

function main ()
{
    export LANG=C;              # Make gcc not use UTF-8.

    if [ -v LRSTAR_DIR ] ; then
        local grammars="${LRSTAR_DIR}/grammars";
        local examples="${LRSTAR_DIR}/examples";
        local grm_name;

        cd ${LRSTAR_DIR};
        for grm in ${grammars}/* ${examples}/*; do
            # The Kotlin lexical grammer is not a dfa grammer, so skip
            # testing until that can be sorted out.
            if [ "$(basename ${grm})" != "Kotlin" ] ; then
                # Pre-cleanup in case last build & test failed.
                #
                # Note that lrstar / dfa cannot be easily run from the
                # build directory via usage of VPATH.  This is true
                # because they write the output into the same place as
                # in the input file.  And lrstar doesn't properly
                # handle the input grammar pathname, incorrectly using
                # the full path.
                #
                # Bottom line, until path handling is improved, ony
                # execute lrstar while the CWD is directory containing
                # the grammar file.
                cleanup "${grm}";
                process "${grm}";

                # Java1 and Java9 test files do not parse
                # correctly.  They are both identical, so
                # I suspect that they both cannot be
                # correct.
                #
                # Similarly, the LRK grammar fails with the default
                # 'k=<val>'.  Up to at least k=5 fails; so skip it.
                #
                grm_name=$(basename "${grm}");
                if [ "${grm_name}" != "Java1" ] &&
                   [ "${grm_name}" != "Java9" ] &&
                   [ "${grm_name}" != "LRK" ]; then
                    if [ -r "${grm}/test.input.txt" ] ; then
                        (cd ${grm};
                         grm_name=$(basename "${grm}");
                         grm_build_dir="${LRSTAR_BUILD_DIR}/${LRSTAR_BUILD_TYPE}/${grm##${LRSTAR_DIR}/}";
                         grm_exec="${grm_build_dir}/${grm_name}";
                         rc=0;
                         if [ -x "${grm_exec}" ] ; then
                             if ! "${grm_exec}" test.input.txt; then
                                 rc=1;
                                 echo "${grm}: test parse failed.";
                             fi;
                             rm test.output.txt;
                             exit ${rc};
                         else
                             echo "${grm_exec} does not exist.  Cannot run test.";
                             exit 1;
                         fi);
                    fi;
                fi;

                cleanup "${grm}";
            fi;
        done;
    else
        echo "LRSTAR environment is not set up.";
        false;
    fi;
}

main "${@}";
