/* Copyright 2018, 2023 Paul B Mann.  BSD License. */

#include <assert.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include "lrstar_basic_defs.h"
#include "CM_Global.h"
#include "PG_Main.h"
#include "PG_CreateTables.h"

typedef enum field_name_t {
#define PFCP(pf_) PF(pf_)
#define PFL(pf_) PF(pf_)
#define PF(pf_) ts_T_##pf_,
   PARSER_FIELDS
#undef PF
#undef PFL
#undef PFCP
   ts_N_ELEMENTS
} field_name_t;


typedef void (*write_user_fn_t)(FILE *fp, const char *fn_name);

/* Info needed to generate
   init_func,
   tact_func,
   nact_func
*/
struct callback_info_t {
   int          N_tacts;
   int          N_nacts;
   const char **Tact_start;
   const char **Nact_start;
};

struct data_types_t {
   const char *type;            /* C type, string form. */
   int         n_elem;          /* Number of elements in array.
                                 * 0 => none.
                                 */
};


typedef void (*file_writer_fn_t)(FILE       *fp,
                                 const char *pathname,
                                 const char *grammar,
                                 const char *fname);


static data_types_t data_types[ts_N_ELEMENTS];
static callback_info_t callback_info;

static const char *get_typestr(int *x, int n)
{
   int i, max = 0, min = 0;
   for (i = 0; i < n; i++)
   {
      if (x[i] > max) max = x[i];
      else if (x[i] < min) min = x[i];
   }
   if (min >= 0)
   {
      if      (max <=        127) return ("uint8"  ); // 1 byte
      else if (max <=        255) return ("uint8"  ); // 1 byte
      else if (max <=      32767) return ("uint16" ); // 2 bytes
      else if (max <=      65535) return ("uint16" ); // 2 bytes
      else if (max <= 2147483647) return ("uint32" ); // 4 bytes
      else                        return ("uint32" ); // 4 bytes
   }
   else if (max > -min)
   {
      if      (max <=        127) return ("int8"   ); // 1 byte
      else if (max <=      32767) return ("int16"  ); // 2 bytes
      else                        return ("int32"  ); // 4 bytes
   }
   else
   {
      if      (min >=       -127) return ("int8"   ); // 1 byte
      else if (min >=     -32767) return ("int16"  ); // 2 bytes
      else                        return ("int32"  ); // 4 bytes
   }
   return (""); // never gets here, avoid compiler error.
}


static const char *
template_decl(void)
{
#define PFCP(pf_) PF(pf_)
#define PF(pf_) "typename T_" #pf_ ", "
#define PFL(pfl_) "typename T_" #pfl_
   static const char *decl = "template<" PARSER_FIELDS ">";
#undef PF
#undef PFCP
#undef PFL
   return decl;
}


static const char *
parser_tables_decl(void)
{
#define PFCP(pf_) PF(pf_)
#define PF(pf_) "T_" #pf_ ", "
#define PFL(pfl_) "T_" #pfl_
   static const char *inst = "templ_lrstar_parser_tables<" PARSER_FIELDS ">";
#undef PF
#undef PFL
#undef PFCP
   return inst;
}


static void
parser_tables_inst(char *buf, size_t buf_len)
{

   snprintf(buf, buf_len,
            "templ_lrstar_parser_tables<\n"
#define PFCP(pf_) PF(pf_)
#define PF(pf_)   "   /* " #pf_ " */  %s,\n"
#define PFL(pfl_) "   /* " #pfl_ " */ %s"
PARSER_FIELDS
#undef PF
#undef PFCP
#undef PFL
            ">",
#define PFCP(pf_) PF(pf_)
#define PF(pf_)   data_types[ts_T_##pf_].type,
#define PFL(pfl_) data_types[ts_T_##pfl_].type
PARSER_FIELDS
#undef PF
#undef PFCP
#undef PFL
      );
}


static void
open_guard(FILE       *fp,
           const char *fname,
           const char *cname,
           const char *ident)
{
   fprintf(fp, "// Generated by %s %s\n// DO NOT EDIT.\n\n", program, version);
   fprintf(fp,
           ("#if !defined(__%s_%s_%s)\n"
            "#define __%s_%s_%s\n\n"),
           fname, cname, ident,
           fname, cname, ident);
}

static void
close_guard(FILE *fp)
{
   fprintf(fp, "\n#endif\n");
}


static size_t
filename_remaining(char       *s,
                   size_t      s_len) /* Elements in s. */
{
   // Returns number of bytes left in 's' for character storage.
   // Leaves 1 byte of space at the end for '\0'.

   size_t len = strlen(s);
   if (len < s_len) {
      return s_len - len - 1;
   } else {
      return 0;
   }
}


static void
create_filename(char       *dst,
                size_t      dst_len, /* Elements in dst. */
                const char *dname,   /* Directory. */
                const char *fname,   /* Filename base. */
                const char *cname,   /* Parser name. */
                const char *suffix,  /* Optional filename suffix. */
                const char *ext)     /* Extension. */
{
   strncpy(dst, dname, dst_len - 1);
   strncat(dst, fname, filename_remaining(dst, dst_len));
   strncat(dst, cname, filename_remaining(dst, dst_len));
   strncat(dst, suffix, filename_remaining(dst, dst_len));
   strncat(dst, ext, filename_remaining(dst, dst_len));
   dst[dst_len - 1] = '\0';
}


static bool
main_init_functions(FILE *fp, int N_tacts, int N_nacts)
{
   if (N_tacts > 0 || N_nacts > 0) {
      fprintf(fp,
              "void %s_init_actions(UNUSED_PARAM(%s_parser_t *parser)); "
              "/* User-supplied */\n"
              "void %s_term_actions(UNUSED_PARAM(%s_parser_t *parser)); "
              "/* User-supplied */\n"
              "static %s_parser_t::init_func_t %s_init_funcs_[2] = {\n"
              "   %s_init_actions,\n"
              "   %s_term_actions\n"
              "};\n\n", gfn, gfn, gfn, gfn, gfn, gfn, gfn, gfn);
      return true;
   } else {
      return false;
   }
}





static bool
main_tact_functions(FILE *fp, int N_tacts, const char **Tact_start)
{
   if (N_tacts > 0) { // Number of terminal actions.
      // Token Actions ...
      for (int t = 0; t < N_tacts; t++) {
         fprintf (fp,
                  "int %s_%s(UNUSED_PARAM(%s_parser_t *parser), "
                  "UNUSED_PARAM(int &t));\n",
                  gfn, Tact_start[t], gfn);
      }
      fprintf(fp,
              "// Terminal action function pointers ...\n"
              "static %s_parser_t::tact_func_t %s_tact_funcs_[%d] = {\n",
              gfn, gfn, N_tacts);
      for (int t = 0; t < N_tacts; t++) {
         fprintf (fp, "   %s_%s,\n", gfn, Tact_start[t]);
      }
      fprintf (fp, "};\n\n");
      return true;
   } else {
      return false;
   }
}


static bool
main_nact_functions(FILE *fp, int N_nacts, const char **Nact_start)
{
   if (N_nacts > 0) {           // Number of node actions
      for (int n = 0; n < N_nacts; n++) {
         if (strcmp (Nact_start[n], "NULL") != 0) {
            fprintf(fp,
                    "int %s_%s(UNUSED_PARAM(%s_parser_t *parser), "
                    "UNUSED_PARAM(Node *node));\n",
                    gfn, Nact_start[n], gfn);
         }
      }

      fprintf(fp, "// Node action function pointers ...\n");
      fprintf(fp, "static %s_parser_t::nact_func_t %s_nact_funcs_[%d] = {\n",
              gfn, gfn, N_nacts);
      for (int n = 0; n < N_nacts; n++) {
         if (strcmp (Nact_start[n], "NULL") == 0) {
            fprintf(fp, "   0,\n");
         } else {
            fprintf(fp, "   %s_%s,\n",  gfn, Nact_start[n]);
         }
      }
      fprintf(fp, "};\n\n");
      return true;
   } else {
      return false;
   }
}


static void
instantiate_field_lengths(FILE *fp)
{
   /* Define the lengths of each array field. */
#define PFCP(pf_) PF(pf_)
#define PFL(pf_) PF(pf_)
#define PF(pf_)                                                         \
   fprintf(fp, ("template<>\n"                                          \
                "const int %s_parser_tables_t::n_" #pf_ " = %d;\n\n"    \
                ""),                                                    \
           gfn,                                                         \
           data_types[ts_T_##pf_].n_elem);
   PARSER_FIELDS
#undef PF
#undef PFCP
#undef PFL
}


void
PG_Main::instantiate_constants(FILE *fp)
{
   // Special constants in the parser.
   fprintf(fp,
           "template<>\n"
           "const int %s_parser_tables_t::n_terms = %d; "
           "// Number of terminals.\n\n",
           gfn, N_terms);

   fprintf(fp,
           "template<>\n"
            "const int %s_parser_tables_t::n_heads = %d; "
            "// Number of nonterminals.\n\n",
           gfn, N_heads);

   fprintf(fp,
           "template<>\n"
           "const int %s_parser_tables_t::n_prods = %d; "
           "// Number of productions.\n\n",
           gfn, N_prods);

   fprintf(fp,
           "template<>\n"
           "const int %s_parser_tables_t::n_states = %d; "
           "// Number of states.\n\n",
           gfn, N_states);

   fprintf(fp,
           "template<>\n"
           "const int %s_parser_tables_t::accept_state = %d; "
           "// Accept state.\n\n",
           gfn, Accept_state);

   fprintf(fp,
           "template<>\n"
           "const int %s_parser_tables_t::n_termactns = %d; "
           "// Number of terminal actions.\n\n",
           gfn, N_tacts);

   fprintf(fp,
           "template<>\n"
           "const int %s_parser_tables_t::n_nodenames = %d; "
           "// Number of node names.\n\n",
           gfn, N_nodes);

   fprintf(fp,
           "template<>\n"
           "const int %s_parser_tables_t::n_nodeactns = %d; "
           "// Number of node actions.\n\n",
           gfn, N_nacts);

   fprintf(fp,
           "template<>\n"
           "const int %s_parser_tables_t::eof_symb = %d; "
           "// <eof> symbol number.\n\n",
           gfn, eof_term);

   fprintf(fp,
           "template<>\n"
           "const int %s_parser_tables_t::err_used = %d; "
           "// <error> used in grammar?\n\n\n",
           gfn, error_used);
}

void PG_Main::instantiate_term_symb_data(FILE *fp)
{
   fprintf(fp, "// Terminal symbols of the grammar.\n");
   fprintf(fp, "static const char *term_symb_[%d] = {\n",
           data_types[ts_T_term_symb].n_elem);
   for (int i = 0; i < N_terms; i++) {
      fprintf(fp, "   \"%s\",\n", make_term(term_name[i]));
   }
   fprintf(fp, "};\n\n");
}


void PG_Main::instantiate_head_symb_data(FILE *fp)
{
   fprintf(fp, "// Nonterminal symbols of the grammar.\n");
   fprintf(fp, "static const char *head_symb_[%d] = {\n",
           data_types[ts_T_head_symb].n_elem);
   for (int i = 0; i < N_heads; i++) {
      fprintf(fp, "   \"%s\",\n", head_name[i]);
   }
   fprintf(fp, "};\n\n");
}


void PG_Main::instantiate_tact_name_data(FILE *fp)
{
   fprintf(fp, "// Terninal action names found in the grammar ...\n");
   fprintf(fp, "static const char *tact_name_[%d] = {\n",
           data_types[ts_T_tact_name].n_elem);
   for (int i = 0; i < N_tacts; i++) {
      fprintf (fp, "   \"%s\",\n", Tact_start[i]);
   }
   fprintf (fp, "};\n\n");
}


void PG_Main::instantiate_node_name_data(FILE *fp)
{
   if (N_nodes > 0) {
      fprintf(fp, "// Node names found in the grammar.\n");
      fprintf(fp, "static const char * node_name_[%d] = {\n", N_nodes);
      for (int i = 0; i < N_nodes; i++) {
         fprintf(fp, "   \"%s\",\n", Node_start[i]);
      }
      fprintf(fp, "\n};\n\n");
   }
}


void PG_Main::instantiate_head_numb_data(FILE *fp)
{
   fprintf(fp, "// Head symbol numbers for the productions.\n");
   fprintf(fp, "static const %s head_numb_[%d] = {",
           data_types[ts_T_head_numb].type,
           data_types[ts_T_head_numb].n_elem);
   for (int i = 0; i < N_prods; i++) {
      if (i % 10 == 0) {
         fprintf(fp, "\n   %5d, ", head_sym[i]);
      }
      else {
         fprintf(fp, "%5d, ", head_sym[i]);
      }
   }
   fprintf(fp, "\n};\n\n");
}


void PG_Main::instantiate_f_tail_data(FILE *fp)
{
   fprintf(fp, "// First tail symbol index into the tail list ...\n");
   fprintf(fp, "static const %s f_tail_[%d] = {",
           data_types[ts_T_f_tail].type,
           data_types[ts_T_f_tail].n_elem);
   for (int i = 0; i < N_prods+1; i++) {
      if (i % 10 == 0) {
         fprintf(fp, "\n   %5d, ", F_tail[i]);
      }
      else fprintf(fp, "%5d, ", F_tail[i]);
   }
   fprintf(fp, "\n};\n\n");
}


void PG_Main::instantiate_tail_data(FILE *fp)
{
   fprintf(fp, "// Tail symbol numbers ...\n");
   fprintf(fp, "static const %s tail_[%d] = {",
            data_types[ts_T_tail].type,
            data_types[ts_T_tail].n_elem);
   for (int i = 0; i < N_tails; i++) {
      if (i % 10 == 0) {
         fprintf(fp, "\n   %5d, ", Tail[i]);
      }
      else fprintf(fp, "%5d, ", Tail[i]);
   }
   fprintf(fp, "\n};\n\n");
}


void PG_Main::instantiate_arga_data(FILE *fp)
{
   if (N_tacts > 0) {
      int *Arga = new int[N_terms];
      for (int i = 0; i < N_terms; i++) {
         if (N_targ[i] > 0) {
            Arga[i] = Arg_numb[F_targ[i]];
         } else {
            Arga[i] = -1;
         }
      }
      fprintf(fp, "// Arguments for token actions ...\n");
      fprintf(fp, "static const %s arga_[%d] = {",
              data_types[ts_T_arga].type,
              data_types[ts_T_arga].n_elem);
      for (int i = 0; i < N_terms; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n   %5d, ", Arga[i]);
         }
         else {
            fprintf(fp, "%5d, ", Arga[i]);
         }
      }
      fprintf(fp, "\n};\n\n");
      delete [] Arga;
   }
}


void PG_Main::instantiate_Bm_data(FILE *fp)
{
   if (optn[PG_BOOLMATRIX] > 0) {
      // B_matrix ...
      fprintf(fp, "// Boolean matrix ...\n");
      fprintf(fp, "static const uint8 Bm_[%d] = {", B_size);
      if (optn[PG_BOOLMATRIX] == 1) { // char
         for (int i = 0; i < B_size; i++) {
            int x = static_cast<uint8>(B_matrix[i]);
            if (i % 10 == 0) {
               fprintf(fp, "\n   %d, ", x);
            }
            else {
               fprintf(fp, "%d, ", x);
            }
         }
      } else if (optn[PG_BOOLMATRIX] == 2) { // bits
         for (int i = 0; i < B_size; i++) {
            int x = static_cast<uint8>(B_matrix[i]);
            if (i % 10 == 0) {
               fprintf(fp, "\n   %5d, ", x);
            } else {
               fprintf(fp, "%5d, ", x);
            }
         }
      }
      fprintf(fp, "\n};\n\n");
   }
}


void PG_Main::instantiate_Br_data(FILE *fp)
{
   if (optn[PG_BOOLMATRIX] > 0) {
      fprintf(fp, "// Boolean matrix row (for state)...\n");
      fprintf(fp, "static const %s Br_[%d] = {",
              data_types[ts_T_Br].type,
              data_types[ts_T_Br].n_elem);
      for (int i = 0; i < N_states; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n   %5d, ", B_row[i]);
         } else {
            fprintf(fp, "%5d, ", B_row[i]);
         }
      }
      fprintf(fp, "\n      };\n\n");
   }
}


void PG_Main::instantiate_Bc_data(FILE *fp)
{
   if (optn[PG_BOOLMATRIX] > 0) {
      fprintf(fp, "// Boolean matrix column (displacement) ...\n");
      fprintf(fp, "static const %s Bc_[%d] = {",
              data_types[ts_T_Bc].type,
              data_types[ts_T_Bc].n_elem);
      for (int i = 0; i < N_terms; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n   %5d, ", B_col[i]);
         }
         else {
            fprintf(fp, "%5d, ", B_col[i]);
         }
      }
      fprintf(fp, "\n      };\n\n");
   }
}


void PG_Main::instantiate_Bf_data(FILE *fp)
{
   if (optn[PG_BOOLMATRIX] > 1) {
      // B_matrix mask ...
      fprintf(fp, "// Boolean matrix filter/mask value ...\n");
      fprintf(fp, "static const uint8 Bf_[%d] = {", N_terms);
      for (int i = 0; i < N_terms; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n   %5d, ", B_mask[i]);
         }
         else {
            fprintf(fp, "%5d, ", B_mask[i]);
         }
      }
      fprintf(fp, "\n};\n\n");
   }
}


void PG_Main::instantiate_Tm_data(FILE *fp)
{
   fprintf(fp, "// Terminal transition matrix ...\n");
   fprintf(fp, "static const %s Tm_[%d] = {",
           data_types[ts_T_Tm].type,
           data_types[ts_T_Tm].n_elem);
   for (int i = 0; i < T_size; i++)
   {
      if (i % 10 == 0) {
         fprintf(fp, "\n   %5d, ", T_matrix[i]);
      } else {
         fprintf(fp, "%5d, ", T_matrix[i]);
      }
   }
   fprintf(fp, "\n};\n\n");
}


void PG_Main::instantiate_Tr_data(FILE *fp)
{
   fprintf(fp, "// Terminal transition matrix row ...\n");
   fprintf(fp, "static const %s Tr_[%d] = {",
           data_types[ts_T_Tr].type,
           data_types[ts_T_Tr].n_elem);
   for (int i = 0; i < tt_states; i++) {
      if (i % 10 == 0) {
         fprintf(fp, "\n   %5d, ", T_row[i]);
      } else {
         fprintf(fp, "%5d, ", T_row[i]);
      }
   }
   fprintf(fp, "\n};\n\n");
}


void PG_Main::instantiate_Tc_data(FILE *fp)
{
   fprintf(fp, "// Terminal transition matrix column ...\n");
   fprintf(fp, "static const %s Tc_[%d] = {",
           data_types[ts_T_Tc].type,
           data_types[ts_T_Tc].n_elem);

   for (int i = 0; i < N_terms; i++) {
      if (i % 10 == 0) {
         fprintf(fp, "\n   %5d, ", T_col[i]);
      } else {
         fprintf(fp, "%5d, ", T_col[i]);
      }
   }
   fprintf(fp, "\n};\n\n");
}


void PG_Main::instantiate_Nm_data(FILE *fp)
{
   fprintf(fp, "// Nonterminal transition matrix ...\n");
   fprintf(fp, "static const %s Nm_[%d] = {",
           data_types[ts_T_Nm].type,
           data_types[ts_T_Nm].n_elem);
   for (int i = 0; i < N_size; i++) {
      if (i % 10 == 0) {
         fprintf(fp, "\n   %5d, ", N_matrix[i]);
      } else {
         fprintf(fp, "%5d, ", N_matrix[i]);
      }
   }
   fprintf(fp, "\n};\n\n");
}


void PG_Main::instantiate_Nr_data(FILE *fp)
{
   fprintf(fp, "// Nonterminal transition matrix row ...\n");
   fprintf(fp, "static const %s Nr_[%d] = {",
           data_types[ts_T_Nr].type,
           data_types[ts_T_Nr].n_elem);
   for (int i = 0; i < ntt_states; i++) {
      if (i % 10 == 0) {
         fprintf(fp, "\n%5d, ", N_row[i]);
      } else {
         fprintf(fp, "%5d, ", N_row[i]);
      }
   }
   fprintf(fp, "\n};\n\n");
}


void PG_Main::instantiate_Nc_data(FILE *fp)
{
   fprintf(fp, "// Nonterminal transition matrix column ...\n");
   fprintf(fp, "static const %s Nc_[%d] = {",
           data_types[ts_T_Nc].type,
           data_types[ts_T_Nc].n_elem);
   for (int i = 0; i < N_prods; i++) {
      if (i % 10 == 0) {
         fprintf(fp, "\n%5d, ", N_col[i]);
      } else {
         fprintf(fp, "%5d, ", N_col[i]);
      }
   }
   fprintf(fp, "\n};\n\n");
}


void PG_Main::instantiate_Rm_data(FILE *fp)
{
   fprintf(fp, "// Reduction matrix ...\n");
   fprintf(fp, "static const %s Rm_[%d] = {",
           data_types[ts_T_Rm].type,
           data_types[ts_T_Rm].n_elem);
   for (int i = 0; i < R_size; i++) {
      if (i % 10 == 0) {
         fprintf(fp, "\n   %5d, ", R_matrix[i]);
      } else {
         fprintf(fp, "%5d, ", R_matrix[i]);
      }
   }
   fprintf(fp, "\n};\n\n");
}


void PG_Main::instantiate_Rr_data(FILE *fp)
{
   fprintf(fp, "// Reduction matrix row ...\n");
   fprintf(fp, "static const %s Rr_[%d] = {",
           data_types[ts_T_Rr].type,
           data_types[ts_T_Rr].n_elem);
   for (int i = 0; i < N_states; i++) {
      if (i % 10 == 0) {
         fprintf(fp, "\n   %5d, ", R_row[i]);
      } else {
         fprintf(fp, "%5d, ", R_row[i]);
      }
   }
   fprintf(fp, "\n};\n\n");
}


void PG_Main::instantiate_Rc_data(FILE *fp)
{
   fprintf(fp, "// Reduction matrix column ...\n");
   fprintf(fp, "static const %s Rc_[%d] = {",
           data_types[ts_T_Rc].type,
           data_types[ts_T_Rc].n_elem);
   for (int i = 0; i < N_terms; i++) {
      if (i % 10 == 0) {
         fprintf(fp, "\n   %5d, ", R_col[i]);
      } else {
         fprintf(fp, "%5d, ", R_col[i]);
      }
   }
   fprintf(fp, "\n};\n\n");
}


void PG_Main::instantiate_PL_data(FILE *fp)
{
   fprintf(fp, "// Production lengths (minus one) ...\n");
   fprintf(fp, "static const %s PL_[%d] = {",
           data_types[ts_T_PL].type,
           data_types[ts_T_PL].n_elem);
   for (int i = 0; i < N_prods; i++) {
      if (i % 10 == 0) {
         fprintf(fp, "\n   %5d, ", prod_len[i]);
      } else {
         fprintf(fp, "%5d, ", prod_len[i]);
      }
   }
   fprintf(fp, "\n};\n\n");
}


void PG_Main::instantiate_tact_numb_data(FILE *fp)
{
   if (N_tacts > 0) {           // Number of terminal actions.
      fprintf(fp, "// Terminal action number ...\n");
      fprintf(fp, "static const %s tact_numb_[%d] = {",
              data_types[ts_T_tact_numb].type,
              data_types[ts_T_tact_numb].n_elem);
      for (int i = 0; i < N_terms; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n   %5d, ", Tact_numb[i]);
         } else {
            fprintf(fp, "%5d, ", Tact_numb[i]);
         }
      }
      fprintf(fp, "\n};\n\n");
   }
}


void PG_Main::instantiate_argx_data(FILE *fp)
{
   if (N_nodes > 0 || N_semantics > 0) {
      int* Argx = new int[N_prods];
      for (int i = 0; i < N_prods; i++) {
         if (N_parg[i] > 0) {
            Argx[i] = Arg_numb[F_parg[i]] - 1;
         } else {
            Argx[i] = -1;
         }
      }
      fprintf(fp, "// First arguments for productions ...\n");
      fprintf(fp, "static const %s argx_[%d] = {",
              data_types[ts_T_argx].type,
              data_types[ts_T_argx].n_elem);
      for (int i = 0; i < N_prods; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n   %5d, ", Argx[i]);
         } else {
            fprintf(fp, "%5d, ", Argx[i]);
         }
      }
      fprintf(fp, "\n};\n\n");

      delete [] Argx;
   }
}


void PG_Main::instantiate_argy_data(FILE *fp)
{
   if (N_semantics > 0) {
      int *Argy = new int[N_prods];
      for (int i = 0; i < N_prods; i++) {
         if (N_parg[i] > 1) {
            Argy[i] = Arg_numb[F_parg[i]+1];
         } else {
            Argy[i] = -1;
         }
      }

      fprintf(fp, "// Second arguments for productions ...\n");
      fprintf(fp, "static const %s argy_[%d] = {",
               data_types[ts_T_argy].type,
               data_types[ts_T_argy].n_elem);

      for (int i = 0; i < N_prods; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n   %5d, ", Argy[i]);
         } else {
            fprintf(fp, "%5d, ", Argy[i]);
         }
      }
      fprintf(fp, "\n};\n\n");
      delete [] Argy;
   }
}


void PG_Main::instantiate_nd_fterm_data(FILE *fp)
{
   if (n_ndstates > 0) {
      // Nondeterministic Items (terminals) in a state ...
      int count = N_states + 1;
      fprintf(fp, "// Nondeterministic first terminal in the list ...\n");
      fprintf(fp, "static const %s nd_fterm_[%d] = {",
              data_types[ts_T_nd_fterm].type,
              data_types[ts_T_nd_fterm].n_elem);
      for (int i = 0; i < count; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n   %5d, ", nd_item[i]);
         } else {
            fprintf(fp, "%5d, ", nd_item[i]);
         }
      }
      fprintf(fp, "\n};\n\n");
   }
}


void PG_Main::instantiate_nd_term_data(FILE *fp)
{
   if (n_ndstates > 0) {
      // Nondeterministic Terminal List ...
      int count = n_ndterms;
      fprintf(fp, "// Nondeterministic terminal list ...\n");
      fprintf(fp, "const %s nd_term_[%d] = {",
              data_types[ts_T_nd_term].type,
              data_types[ts_T_nd_term].n_elem);
      for (int i = 0; i < count; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n   %5d, ", nd_term[i]);
         } else {
            fprintf(fp, "%5d, ", nd_term[i]);
         }
      }
      fprintf(fp, "\n};\n\n");
   }
}


void PG_Main::instantiate_nd_faction_data(FILE *fp)
{
   if (n_ndstates > 0) {
      // Nondeterministic Start of a terminal's actions for state ...
      int count = n_ndterms + 1;
      fprintf(fp, "// Nondeterministic first action in the list ...\n");
      fprintf(fp, "static const %s nd_faction_[%d] = {",
              data_types[ts_T_nd_faction].type,
              data_types[ts_T_nd_faction].n_elem);
      for (int i = 0; i < count; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n   %5d, ", nd_start[i]);
         } else {
            fprintf(fp, "%5d, ", nd_start[i]);
         }
      }
      fprintf(fp, "\n};\n\n");
   }
}


void PG_Main::instantiate_nd_action_data(FILE *fp)
{
   if (n_ndstates > 0) {
      // Nondeterministic Action ...
      int count = n_nditems;
      fprintf(fp, "// Nondeterministic actions list ...\n");
      fprintf(fp, "static const %s nd_action_[%d] = {",
              data_types[ts_T_nd_action].type,
              data_types[ts_T_nd_action].n_elem);
      for (int i = 0; i < count; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n   %5d, ", nd_action[i]);
         } else {
            fprintf(fp, "%5d, ", nd_action[i]);
         }
      }
      fprintf(fp, "\n};\n\n");
   }
}


void PG_Main::instantiate_node_numb_data(FILE *fp)
{
   if (optn[PG_ASTCONST] > 0 && N_nodes > 0) {
      fprintf(fp, "// Node number for each production ...\n");
      fprintf(fp, "static const %s node_numb_[%d] = {",
              data_types[ts_T_node_numb].type,
              data_types[ts_T_node_numb].n_elem);
      for (int i = 0; i < N_prods; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n   %5d, ", Node_numb[i]);
         } else {
            fprintf(fp, "%5d, ", Node_numb[i]);
         }
      }
      fprintf(fp, "\n};\n\n");
   }
}


void PG_Main::instantiate_nact_numb_data(FILE *fp)
{
   if (optn[PG_ASTCONST] > 0 && N_nodes > 0) {
      if (N_nacts > 0) {
         fprintf(fp, "// Node action numbers ...\n");
         fprintf(fp, "static const %s nact_numb_[%d] = {",
                 data_types[ts_T_nact_numb].type,
                 data_types[ts_T_nact_numb].n_elem);
         for (int i = 0; i < N_prods; i++) {
            if (i % 10 == 0) {
               fprintf(fp, "\n   %5d, ", Nact_numb[i]);
            } else {
               fprintf(fp, "%5d, ", Nact_numb[i]);
            }
         }
         fprintf(fp, "\n};\n\n");
      }
   }
}


void PG_Main::instantiate_reverse_data(FILE *fp)
{
   if (optn[PG_ASTCONST] > 0 && N_nodes > 0) {
      if (N_reverses > 0) {
         // Reverse the order of nodes (for a production/rule) ...
         fprintf(fp, "// Reverse the order of nodes ...\n");
         fprintf(fp, "static const uint8 reverse_[%d] = {", N_prods);
         for (int i = 0; i < N_prods; i++) {
            if (i % 10 == 0) {
               fprintf(fp, "\n   %5d, ", Reverse[i]);
            } else {
               fprintf(fp, "%5d, ", Reverse[i]);
            }
         }
         fprintf(fp, "\n};\n\n");
      }
   }
}


void
PG_Main::instantiate_fields(FILE *fp)
{
   char parser[1024];

   parser_tables_inst(parser, sizeof(parser) / sizeof(parser[0]));

#define PFCP(pf_)                                           \
   if (data_types[ts_T_##pf_].n_elem != 0) {                \
      instantiate_##pf_##_data(fp);                         \
      fprintf(fp, ("template<>\n"                           \
                   "%s *%s_parser_tables_t::" #pf_ " = &%s[0];\n\n"         \
                   ""),                                     \
              data_types[ts_T_##pf_].type,                  \
              gfn,                                          \
              #pf_ "_");                                    \
   } else {                                                 \
      fprintf(fp, ("template<>\n"                           \
                   "%s *%s_parser_tables_t::" #pf_ " = 0;\n\n"              \
                   ""),                                     \
              data_types[ts_T_##pf_].type,                  \
              gfn);                                         \
   }
#define PFL(pf_) PF(pf_)
#define PF(pf_)                                             \
   if (data_types[ts_T_##pf_].n_elem != 0) {                \
      instantiate_##pf_##_data(fp);                         \
      fprintf(fp, ("template<>\n"                           \
                   "const %s *%s_parser_tables_t::" #pf_ " = &%s[0];\n\n"   \
                   ""),                                     \
              data_types[ts_T_##pf_].type,                  \
              gfn,                                          \
              #pf_ "_");                                    \
   } else {                                                 \
      fprintf(fp, ("template<>\n"                           \
                   "const %s *%s_parser_tables_t::" #pf_ " = 0;\n\n"        \
                   ""),                                     \
              data_types[ts_T_##pf_].type,                  \
              gfn);                                         \
   }
   PARSER_FIELDS
#undef PF
#undef PFCP
#undef PFL
}


void
PG_Main::typedef_tables(const char *dname,
                        const char *fname,
                        const char *cname)
{
   FILE *fp;
   char parser[1024];
   char pathname[PATH_MAX];

   parser_tables_inst(parser, sizeof(parser) / sizeof(parser[0]));
   create_filename(pathname, PATH_MAX, dname, fname, cname,
                   "_typedef", ".h");

   fp = fopen(pathname, "w");
   if (fp == NULL) {
      prt_log("Output file '%s' cannot be created.\n", pathname);
      Quit();
   }

   open_guard(fp, fname, cname, "TYPEDEF");
   fprintf(fp, "#include \"lrstar_parser_tables.h\"\n");
   fprintf(fp, "typedef %s %s_parser_tables_t;\n\n", parser, gfn);
   close_guard(fp);
   fclose(fp);
}


static void
set_data_type_int32(field_name_t field_name)
{
   data_types[field_name].type   = "int32";
   data_types[field_name].n_elem = 0;
}


void
PG_Main::GenerateParserTableEnums(FILE *fp)
{
   int i;
   if (n_constants > 0) {
      fprintf(fp, "enum termcon {\n");
      for (i = 0; i < n_constants; i++) {
         fprintf(fp, "   %s = %d,\n", Defcon_name[i], Defcon_value[i]);
      }
      fprintf(fp, "};\n\n");
   }

   if (N_nodes > 0 && optn[PG_ASTCONST] > 0) {
      fprintf(fp, "enum nodecon {\n");
      for (int i = 0; i < N_nodes; i++) {
         fprintf(fp, "   N_%s = %d,\n", Node_start[i], i);
      }
      fprintf(fp, "};\n\n");
   }
}

void  PG_Main::GenerateParserTables ()
{
   //int   i;
   int   count;
   //FILE* header;
   const char* name  = "_ParserTables";

   if (optn[PG_TERMACTIONS ] == 0) N_tacts = 0;
   if (optn[PG_NODEACTIONS ] == 0) N_nacts = 0;


   data_types[ts_T_term_symb].type   = "const char * const";
   data_types[ts_T_term_symb].n_elem = N_terms;

   data_types[ts_T_head_symb].type   = "const char * const";
   data_types[ts_T_head_symb].n_elem = N_heads;

   data_types[ts_T_tact_name].type    = "const char * const";
   data_types[ts_T_tact_name].n_elem  = N_tacts;

   data_types[ts_T_node_name].type   = "const char * const";
   data_types[ts_T_node_name].n_elem = N_nodes;

   nd_optimize ();

   // Head numbers for the productions ...
   data_types[ts_T_head_numb].type   = get_typestr (head_sym, N_prods);
   data_types[ts_T_head_numb].n_elem = N_prods;

   // Index to first tail symbol for a production ...
   data_types[ts_T_f_tail].type   = get_typestr (F_tail, N_prods + 1);
   data_types[ts_T_f_tail].n_elem = N_prods + 1;

   // Tail symbol numbers ...
   data_types[ts_T_tail].type   = get_typestr (Tail, N_tails);
   data_types[ts_T_tail].n_elem = N_tails;

   // Arguments for terminal actions ...
   if (N_tacts > 0)
   {
      int* Arga = new int[N_terms];
      for (int i = 0; i < N_terms; i++)
      {
         if (N_targ[i] > 0)
            Arga[i] = Arg_numb[F_targ[i]];
         else
            Arga[i] = -1;
      }
      data_types[ts_T_arga].type   = get_typestr (Arga, N_terms);
      data_types[ts_T_arga].n_elem = N_terms;
   } else {
      set_data_type_int32(ts_T_arga);
   }

   // First arguments for productions ...
   if (N_nodes > 0 || N_semantics > 0)
   {
      int* Argx = new int[N_prods];
      for (int i = 0; i < N_prods; i++)
      {
         if (N_parg[i] > 0)
            Argx[i] = Arg_numb[F_parg[i]] - 1;
         else
            Argx[i] = -1;
      }
      data_types[ts_T_argx].type   = get_typestr (Argx, N_prods);
      data_types[ts_T_argx].n_elem = N_prods;
   } else {
      set_data_type_int32(ts_T_argx);
   }

   // Second arguments for productions ...
   if (N_semantics > 0)
   {
      int* Argy = new int[N_prods];
      for (int i = 0; i < N_prods; i++)
      {
         if (N_parg[i] > 1)
            Argy[i] = Arg_numb[F_parg[i]+1];
         else
            Argy[i] = -1;
      }

      data_types[ts_T_argy].type   = get_typestr (Argy, N_prods);
      data_types[ts_T_argy].n_elem = N_prods;
   } else {
      set_data_type_int32(ts_T_argy);
   }

   if (optn[PG_BOOLMATRIX] > 0)
   {
      // B_matrix ...
      data_types[ts_T_Bm].type   = "uint8";
      data_types[ts_T_Bm].n_elem = B_size;

      // B_matrix row ...
      data_types[ts_T_Br].type   = get_typestr (B_row, N_states);
      data_types[ts_T_Br].n_elem = N_states;

      // B_matrix column ...
      data_types[ts_T_Bc].type   = get_typestr (B_col, N_terms);
      data_types[ts_T_Bc].n_elem = N_terms;

      if (optn[PG_BOOLMATRIX] > 1)
      {
         // B_matrix mask ...
         data_types[ts_T_Bf].type   = "uint8";
         data_types[ts_T_Bf].n_elem = N_terms;
      }
   }

   // T_matrix ...
   data_types[ts_T_Tm].type   = get_typestr (T_matrix, T_size);
   data_types[ts_T_Tm].n_elem = T_size;

   // T_matrix row ...
   data_types[ts_T_Tr].type   = get_typestr (T_row, tt_states);
   data_types[ts_T_Tr].n_elem = tt_states;

   // T_matrix column ...
   data_types[ts_T_Tc].type   = get_typestr (T_col, N_terms);
   data_types[ts_T_Tc].n_elem = N_terms;

   // N_matrix ...
   data_types[ts_T_Nm].type   = get_typestr (N_matrix, N_size);
   data_types[ts_T_Nm].n_elem = N_size;

   // N_matrix row ...
   data_types[ts_T_Nr].type   = get_typestr (N_row, ntt_states);
   data_types[ts_T_Nr].n_elem = ntt_states;

   // N_matrix column ...
   data_types[ts_T_Nc].type   = get_typestr (N_col, N_prods);
   data_types[ts_T_Nc].n_elem = N_prods;

   // R_matrix ...
   data_types[ts_T_Rm].type   = get_typestr (R_matrix, R_size);
   data_types[ts_T_Rm].n_elem = R_size;

   // R_matrix row ...
   data_types[ts_T_Rr].type   = get_typestr (R_row, N_states);
   data_types[ts_T_Rr].n_elem = N_states;

   // R_matrix column ...
   data_types[ts_T_Rc].type   = get_typestr (R_col, N_terms);
   data_types[ts_T_Rc].n_elem = N_terms;

   // Production length - 1 ...
   data_types[ts_T_PL].type   = get_typestr (prod_len, N_prods);
   data_types[ts_T_PL].n_elem = N_prods;

   int newline = 0;
   if (n_ndstates > 0)
   {
      newline = 1;
      // Nondeterministic Items (terminals) in a state ...
      count = N_states + 1;
      data_types[ts_T_nd_fterm].type   = get_typestr (nd_item, count);
      data_types[ts_T_nd_fterm].n_elem = count;

      // Nondeterministic Terminal List ...
      count = n_ndterms;
      data_types[ts_T_nd_term].type   = get_typestr (nd_term, count);
      data_types[ts_T_nd_term].n_elem = count;

      // Nondeterministic Start of a terminal's actions for state ...
      count = n_ndterms + 1;
      data_types[ts_T_nd_faction].type   = get_typestr (nd_start, count);
      data_types[ts_T_nd_faction].n_elem = count;

      // Nondeterministic Action ...
      count = n_nditems;
      data_types[ts_T_nd_action].type   = get_typestr (nd_action, count);
      data_types[ts_T_nd_action].n_elem = count;
   } else {
      set_data_type_int32(ts_T_nd_fterm);
      set_data_type_int32(ts_T_nd_term);
      set_data_type_int32(ts_T_nd_faction);
      set_data_type_int32(ts_T_nd_action);
   }

   newline = 0;
   if (N_tacts > 0) // Number of terminal actions.
   {
      newline = 1;
      // Token Action numbers ...
      data_types[ts_T_tact_numb].type   = get_typestr (Tact_numb, N_terms);
      data_types[ts_T_tact_numb].n_elem = N_terms;
   } else {
      set_data_type_int32(ts_T_tact_numb);
   }

   if (optn[PG_ASTCONST] > 0 && N_nodes > 0)
   {
      if (newline == 0) {
         newline = 1;
      }
      // Node Number for each production ...
      data_types[ts_T_node_numb].type   = get_typestr (Node_numb, N_prods);
      data_types[ts_T_node_numb].n_elem = N_prods;

      if (N_nacts > 0) // Number of node actions
      {
         // Node Action numbers ...
         data_types[ts_T_nact_numb].type   = get_typestr (Nact_numb, N_prods);
         data_types[ts_T_nact_numb].n_elem = N_prods;
      } else {
         set_data_type_int32(ts_T_nact_numb);
      }


      if (N_reverses > 0)
      {
         // Reverse the order of nodes (for a production/rule) ...
         data_types[ts_T_reverse].type   = "uint8";
         data_types[ts_T_reverse].n_elem = N_prods;
      } else {
         set_data_type_int32(ts_T_reverse);
      }
   } else {
      set_data_type_int32(ts_T_node_numb);
      set_data_type_int32(ts_T_nact_numb);
      set_data_type_int32(ts_T_reverse);
   }
   typedef_tables(gdn, gfn, name);
};


static void
generate_grammar_parser_typedef(FILE *fp, const char *grammar)
{
   static const int  stksize = 100;       // Parser-stack size.
   static const char *b[] = { "false", "true" };
   static const char templ[] = "typedef lrstar_parser<";

   fprintf(fp, "extern const char %s_grammar_name[];\n\n", gfn);

   fprintf(fp, "%s", templ);
   fprintf(fp,
           "/* grammar           */   %s_grammar_name", gfn);
   fprintf(fp, ",\n%*s"
           "/* actions           */   %s",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           b[PG_Main::N_tacts > 0 || PG_Main::N_nacts > 0]);
   fprintf(fp, ",\n%*s"
           "/* debug_parser      */   %s",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           b[!!optn[PG_DEBUG]]);
   fprintf(fp, ",\n%*s"
           "/* debug_trace       */   %s",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           b[!!optn[PG_DEBUGTRACE]]);
   fprintf(fp, ",\n%*s"
           "/* expecting         */   %s",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           b[optn[PG_EXPECTING] || PG_Main::error_used > 0]);
   fprintf(fp, ",\n%*s"
           "/* insensitive       */   %s",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           b[!!optn[PG_INSENSITIVE]]);
   fprintf(fp, ",\n%*s"
           "/* lookaheads        */   %d",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           optn[PG_LOOKAHEADS]);
   fprintf(fp, ",\n%*s"
           "/* make_ast          */   %s",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           b[optn[PG_ASTCONST] && PG_Main::N_nodes > 0]);
   fprintf(fp, ",\n%*s"
           "/* nd_parsing        */   %s",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           b[PG_Main::n_ndstates > 0]);
   fprintf(fp, ",\n%*s"
           "/* nd_threads        */   %d",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           PG_Main::n_ndstates > 0 ? PG_Main::nd_maxcount : 0);
   fprintf(fp, ",\n%*s"
           "/* node_actions      */   %s",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           b[PG_Main::N_nacts > 0]);
   fprintf(fp, ",\n%*s"
           "/* reversable        */   %s",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           b[PG_Main::N_reverses > 0]);
   fprintf(fp, ",\n%*s"
           "/* semantics         */   %s",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           b[PG_Main::N_semantics > 0]);
   fprintf(fp, ",\n%*s"
           "/* stksize           */   %d",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           stksize);
   fprintf(fp, ",\n%*s"
           "/* term_actions      */   %s",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           b[PG_Main::N_tacts > 0]);
   fprintf(fp, ",\n%*s"
           "/* lexer table type  */   %s_lexer_t",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           grammar);
   fprintf(fp, ",\n%*s"
           "/* parser table type */   %s_parser_tables_t",
           static_cast<int>(sizeof(templ) / sizeof(templ[0])) - 1, " ",
           grammar);
   fprintf(fp, "> %s_parser_t;\n", grammar);
}


static void
generate_parser_allocation(FILE *fp)
{
   //static const int  stksize  = 100; // Parser-stack size.
   //static const char *b[]     = { "false", "true" };
   static const char prefix[] = "   return new ";
   static const char suffix[] = "_parser_t(";
   int               space_width;
   char             *templ;
   int               templ_len;
   bool              init_fn;
   bool              tact_fn;
   bool              nact_fn;

   init_fn = main_init_functions(fp,
                                 callback_info.N_tacts,
                                 callback_info.N_nacts);

   tact_fn = main_tact_functions(fp,
                                 callback_info.N_tacts,
                                 callback_info.Tact_start);

   nact_fn = main_nact_functions(fp,
                                 callback_info.N_nacts,
                                 callback_info.Nact_start);

   templ_len = ((sizeof(prefix) / sizeof(prefix[0]) - 1) +
                (sizeof(suffix) / sizeof(suffix[0]) - 1) +
                strlen(gfn));
   templ = new char[templ_len + 1];
   sprintf(templ, "%s%s%s", prefix, gfn, suffix);

   space_width = strlen(gfn) + strlen("_new_parser") + 1;
   fprintf(fp,
           "%s_parser_t *\n%s_new_parser(const char *input_path,\n"
           "%*schar       *input_text,\n"
           "%*sunsigned    max_symbols"
           ")\n"
           "{\n"
           "%s",
           gfn, gfn, space_width, " ", space_width, " ", templ);

   fprintf(fp, "/* input path   */   input_path");

   fprintf(fp, ",\n%*s"
           "/* input text   */   input_text",
           static_cast<int>(templ_len), " ");

   fprintf(fp, ",\n%*s"
           "/* max symbols  */   max_symbols",
           static_cast<int>(templ_len), " ");

   if (init_fn) {
      fprintf(fp, ",\n%*s"
              "/* init_func    */   &%s_init_funcs_[0]",
              static_cast<int>(templ_len), " ",
              gfn);
   } else {
      fprintf(fp, ",\n%*s"
              "/* init_func    */   0",
              static_cast<int>(templ_len), " ");
   }

   if (tact_fn) {
      fprintf(fp, ",\n%*s"
              "/* tact_func    */   &%s_tact_funcs_[0]",
              static_cast<int>(templ_len), " ",
              gfn);
   } else {
      fprintf(fp, ",\n%*s"
              "/* tact_func    */   0",
              static_cast<int>(templ_len), " ");
   }

   if (nact_fn) {
      fprintf(fp, ",\n%*s"
              "/* nact_func    */   &%s_nact_funcs_[0]",
              static_cast<int>(templ_len), " ",
              gfn);

   } else {
      fprintf(fp, ",\n%*s"
              "/* nact_func    */   0",
              static_cast<int>(templ_len), " ");
   }

   fprintf(fp, ");\n}\n\n");

}

static void
instantiate_generated_parser(FILE *fp)
{
   fprintf(fp, "\n");
   fprintf(fp, "const char %s_grammar_name[] = \"%s\";\n", gfn, gfn);
   fprintf(fp, "\n");

   fprintf(fp, "\n");
   generate_parser_allocation(fp);
}


static void
parser_header_fn(FILE       *fp,
                 const char *pathname,
                 const char *grammar,
                 const char *fname)
{
   open_guard(fp, grammar, "Parser", "H");

   fprintf (fp, "#include \"lrstar_basic_defs.h\"\n");
   if (lrstar_linux) {
      fprintf (fp, "#include \"lrstar_lexer.h\"\n");
   }

   fprintf(fp, "\n");
   PG_Main::GenerateParserTableEnums(fp);

   fprintf(fp, "#include \"%s_ParserTables_typedef.h\"\n", grammar);
   fprintf(fp, "#include \"lrstar_parser.h\"\n\n");
   generate_grammar_parser_typedef(fp, grammar);
   close_guard(fp);
}


static void
write_user_preamble(FILE *fp)
{
   fprintf(fp,
           "/* This file is created by lrstar.\n"
           " *\n"
           " *\n"
           " *  NOTE: lrstar will never rewrite or delete this file.\n"
           " *        It can be safely edited to add user-supplied code.\n"
           " */\n"
           "\n");
}

static void
write_user_init(FILE *fp, const char *fn_name)
{
   write_user_preamble(fp);
   fprintf(fp,
           "void\n"
           "%s_%s(UNUSED_PARAM(%s_parser_t *parser))\n"
           "{\n"
           "      /* Initialization code goes here */\n"
           "}\n",
           gfn, fn_name, gfn);
}


static void
write_user_term(FILE *fp, const char *fn_name)
{
   write_user_preamble(fp);
   fprintf(fp,
           "void\n"
           "%s_%s(UNUSED_PARAM(%s_parser_t *parser))\n"
           "{\n"
           "      /* Termination code goes here */\n"
           "}\n",
           gfn, fn_name, gfn);
}


static void
write_user_error(FILE *fp, const char *fn_name)
{
   write_user_preamble(fp);
   fprintf(fp,
           "int\n"
           "%s_%s(UNUSED_PARAM(%s_parser_t *parser), "
           "UNUSED_PARAM(int &t))\n"
           "{\n"
           "   if (parser->lt.token.end == parser->lt.token.start) {\n"
           "      // An illegal character.\n"
           "      parser->lt.token.end++;\n"
           "   }\n"
           "   return 0;\n"
           "}\n",
           gfn, fn_name, gfn);
}


static void
write_user_lookup(FILE *fp, const char *fn_name)
{
   write_user_preamble(fp);
   fprintf(fp,
           "int\n"
           "%s_%s(UNUSED_PARAM(%s_parser_t *parser), "
           "UNUSED_PARAM(int &t))\n"
           "{\n"
           "   // Lookup in symbol table.\n\n"
           "   int sti;\n"
           "\n"
           "   if (parser->opt_nd_parsing() &&\n"
           "       parser->lt.lookahead.start != 0) {\n"
           "      // In lookahead mode.\n"
           "      sti = parser->add_symbol(t, parser->lt.lookahead.start,\n"
           "                               parser->lt.lookahead.end);\n"
           "   } else {\n"
           "      // Regular mode of parsing\n"
           "      sti = parser->add_symbol(t, parser->lt.token.start,\n"
           "                               parser->lt.token.end);\n"
           "   }\n\n"
           "   if (parser->opt_semantics()) {\n"
           "      // Redefine terminal number?\n"
           "      t = parser->symbol[sti].term;\n"
           "   }\n\n"
           "   return sti; // Return symbol-table index.\n"
           "}\n",
           gfn, fn_name, gfn);
}


static void
write_user_nact(FILE *fp, const char *fn_name)
{
   write_user_preamble(fp);
   fprintf(fp,
           "void\n"
           "%s_%s(UNUSED_PARAM(%s_parser_t *parser), "
           "UNUSED_PARAM(Node *v))\n"
           "{\n"
           "}\n",
           gfn, fn_name, gfn);
}


static void
write_user_header(FILE *fp, const char *fn_name)
{
   fprintf(fp,
           "/* This file is created by lrstar.\n"
           " *\n"
           " * This file can be used to add any code that must be\n"
           " * available to all the user-defined functions.  For example,\n"
           " * if string comparisons are needed, '#include <string.h>'.\n"
           " *\n"
           " *\n"
           " *  NOTE: lrstar will never rewrite or delete this file.\n"
           " *        It can be safely edited to add user-supplied code.\n"
           " */\n"
           "#if !defined(__%s_USER_HEADER__)\n"
           "\n"
           "\n"
           "\n"
           "#endif\n", gfn);
}


static void
user_write_include_and_file(FILE            *fp,
                            const char      *grammar,
                            const char      *fn_name,
                            write_user_fn_t  fn)
{
   char        pathname[PATH_MAX];
   struct stat statbuf;
   bool        exists;

   if (fn_name != 0) {
      /* Per-callout function header file. */
      fprintf(fp, "#include \"%s_user_%s.h\"\n", grammar, fn_name);
      snprintf(&pathname[0], sizeof(pathname) / sizeof(pathname[0]),
               "%s_user_%s.h", grammar, fn_name);
   } else {
      /* Global user header file. */
      fprintf(fp, "#include \"%s_user.h\"\n", grammar);
      snprintf(&pathname[0], sizeof(pathname) / sizeof(pathname[0]),
               "%s_user.h", grammar);
   }

   exists = stat(pathname, &statbuf) != -1;
   /*  The code in the functions is contained in these files is
    *  written by the user.  Consequently, lrstar will only create the
    *  file with the proper signature; lrstar will never overwrite or
    *  delete these files.
    */
   if (!exists) {
      FILE *ifp = fopen(pathname, "w");
      if (fn != NULL) {
         (*fn)(ifp, fn_name);
      }
      fclose(ifp);
   }
}

static void
user_written_cpp_fn(FILE       *fp,
                    const char *pathname,
                    const char *grammar,
                    const char *fname)
{
   fprintf(fp,
           ("/* This file is generated by lrstar and will be "
            "overwritten by it. */\n\n"
            "#include \"lrstar_basic_defs.h\"\n"
            "#include \"%s_LexerTables_typedef.h\"\n"
            "#include \"%s_Parser.h\"\n"),
           grammar, grammar);

   user_write_include_and_file(fp, grammar, NULL, write_user_header);
   user_write_include_and_file(fp, grammar, "init_actions", write_user_init);
   user_write_include_and_file(fp, grammar, "term_actions", write_user_term);
   user_write_include_and_file(fp, grammar, "error", write_user_error);
   user_write_include_and_file(fp, grammar, "lookup", write_user_lookup);

   if (callback_info.N_nacts > 0) {
      int          N_nacts    = callback_info.N_nacts;
      const char **Nact_start = callback_info.Nact_start;
      int          n          = 0;

      while (n < N_nacts) {
         if (strcmp(Nact_start[n], "NULL") != 0) {
            user_write_include_and_file(fp, grammar, Nact_start[n],
                                        write_user_nact);
         }
         n++;
      }
   }
}


static void main_cpp_fn(FILE       *fp,
                        const char *pathname,
                        const char *grammar,
                        const char *fname)
{
   fprintf(fp,
           "#include \"lrstar_basic_defs.h\"\n"
           "#include \"%s_LexerTables_typedef.h\"\n"
           "#include \"%s_Parser.h\"\n"
           "\n", grammar, grammar);
   if (lrstar_linux) {
      instantiate_generated_parser(fp);
   } else {
      assert(lrstar_windows);
      fprintf (fp, "#include \"../../code/main.cpp\"\n");
   }
}


static void
parser_cpp_fn(FILE       *fp,
              const char *pathname,
              const char *grammar,
              const char *fname)
{
   char parser[1024];

   parser_tables_inst(parser, sizeof(parser) / sizeof(parser[0]));

   fprintf (fp, ("#include \"lrstar_basic_defs.h\"\n"
                 "#include \"lrstar_parser_tables.h\"\n"
                 "#include \"%s_LexerTables_typedef.h\"\n"
                 "#include \"%s_ParserTables_typedef.h\"\n"
                 "#include \"%s_Parser.h\"\n\n"),
            grammar, grammar, grammar);

   instantiate_field_lengths(fp);
   PG_Main::instantiate_constants(fp);
   PG_Main::instantiate_fields(fp);
}


static void make_bat_fn(FILE       *fp,
                        const char *pathname,
                        const char *grammar,
                        const char *fname)
{
   // TODO: need grammar name to be passed, too
   fprintf (fp, "rem  This make.bat must be in the same directory as the Visual Studio project files,\n");
   fprintf (fp, "rem  or else the error messages will not have the correct directory name preceeding\n");
   fprintf (fp, "rem  the file name, and clicking on the error messages will not work.\n");
   fprintf (fp, "\n");
   fprintf (fp, "@echo off\n");
   fprintf (fp, "prompt $g$s\n");
   fprintf (fp, "\n");
   fprintf (fp, "..\\..\\bin\\lrstar %s d dt\n", grammar);
   fprintf (fp, "..\\..\\bin\\dfa    %s d\n\n", grammar);
}


static void makefile_fn(FILE       *fp,
                        const char *pathname,
                        const char *grammar,
                        const char *fname)
{
   static const char *make = (
      "# Build '%s' parser.\n" /* grammar */
      "\n\n"
      "GRM\t\t:= %s\n" /* grammar */
      ".DEFAULT_GOAL\t:= recurse\n"
      "\n\n"
      "INSTALL_ROOT :=\t\t\t\\\n"
      "\t$(if $(LRSTAR_INSTALL_ROOT),$(LRSTAR_INSTALL_ROOT),/usr/local)\n"
      "\n\n"
      "include $(LRSTAR_INSTALL_ROOT)/make/sample.defs\n"
      "\n\n"
      "SOURCE\t:=\t\t\t\\\n"
      "\t$(GRM)_Lexer.cpp\t\\\n"
      "\t$(GRM)_Main.cpp\t\t\\\n"
      "\t$(GRM)_Parser.cpp\t\\\n"
      "\t$(GRM)_user.cpp\t\t\\\n"
      "\t$(GRM)_user_main.cpp\t\t\\\n"
      "\n\n"
      "OBJS\t:= $\t$(SOURCE:.cpp=.o) $(LRSTAR_INSTALL_ROOT)/lib/lrstar.a\n"
      "\n\n"
      "$(GRM)_Parser.cpp:\t$(GRM).grm\n"
      "\t$(LRSTAR) $<\n"
      "\n\n"
      "$(GRM)_LexerTables_typedef.h:\t$(GRM).lgr $(GRM)_Parser.cpp\n"
      "\t$(DFA) $<\n"
      "\n\n"
      "$(GRM)_Lexer.o:\t$(GRM)_LexerTables_typedef.h\n"
      "\n\n"
      "$(GRM):\t$(OBJS)\n"
      "\t$(CC) $(CXXFLAGS) -o $@ $(OBJS);\n"
      "\n\n"
      "clean:\n"
      "\trm $(SOURCE) $(OBJS) $(GRM);");
   fprintf(fp, make, grammar, grammar, grammar, pathname);
}


static void write_file(const char       *gdn,
                       const char       *grammar,
                       const char       *fname,
                       const char       *suffix,
                       bool              overwrite,
                       file_writer_fn_t  fn)
{
   char         pathname[PATH_MAX];
   FILE        *fp;
   int          stat_res;
   struct stat  statbuf;
   bool         exists;

   strcpy(pathname, gdn);

   /* If a filename is provided, it overrides the gammar + suffix in
    * the filename.
    */
   if (fname != NULL) {
      strcat(pathname, fname);
   } else {
      strcat(pathname, grammar);
      strcat(pathname, suffix);
   }

   stat_res = stat(pathname, &statbuf);
   exists   = stat_res != -1;

   if (!exists || overwrite) {
      fp = fopen(pathname, "w");

      if (fp != NULL) {
         prt_logonly ("Generating: %s\n", pathname);

         fn(fp, pathname, grammar, fname);
         fclose(fp);
      } else {
         if (++n_errors == 1) {
            prt_log("\n");
         }
         prt_log("Output file '%s' cannot be written!\n\n", pathname);
         Quit();
      }
   }
}


static void instantiate_getopt(FILE *fp)
{
   fprintf(fp,
           "extern \"C\" {\n"
           "    typedef struct options_t {\n"
           "       char *output;           /* Pathname of lrstar output file. */\n"
           "       unsigned iterations;    /* Number of times to parse file. */\n"
           "    } options_t;\n"
           "\n"
           "\n"
           "    options_t options;\n"
           "\n"
           "    static struct option long_options[] = {\n"
           "        { \"help\",        no_argument,       NULL,  256 },\n"
           "        { \"output\",      required_argument, NULL,  257 },\n"
           "        { \"iterations\",  required_argument, NULL,  258 },\n"
           "        { NULL,      no_argument,       NULL,    0 }\n"
           "    };\n"
           "\n"
           "\n"
           "    static void\n"
           "    help(const char *exec)\n"
           "    {\n"
           "        printf(\"\\n\\n\"\n"
           "               \"%%s [--help | --output <pathname>]... <file>\\n\\n\", exec);\n"
           "        printf(\"  --help  :   Print this help message and exit.\\n\"\n"
           "               \"  --output:   Provides path of file to which lrstar will write.\\n\"\n"
           "               \"\\n\");\n"
           "    }\n"
           "\n"
           "\n"
           "    static void\n"
           "    init_options(options_t *opts)\n"
           "    {\n"
           "        opts->output = 0;\n"
           "        opts->iterations = 1;\n"
           "    }\n"
           "\n"
           "\n"
           "    static int                  // Returns optind\n"
           "    get_options(int argc, char *argv[], options_t *opts)\n"
           "    {\n"
           "        int c;\n"
           "\n"
           "        init_options(opts);\n"
           "\n"
           "        while (1) {\n"
           "            int option_index = 0;\n"
           "\n"
           "            c = getopt_long(argc, argv, \"\", long_options, &option_index);\n"
           "            if (c == -1) {\n"
           "                break;\n"
           "            }\n"
           "\n"
           "            switch (c) {\n"
           "            case 256:\n"
           "                help(argv[0]);\n"
           "                exit(0);\n"
           "                break;\n"
           "\n"
           "            case 257:\n"
           "                opts->output = strdup(optarg);\n"
           "                break;\n"
           "\n"
           "            case 258:\n"
           "                opts->iterations = static_cast<unsigned>(abs(atoi(optarg)));\n"
           "                break;\n"
           "\n"
           "            default:\n"
           "                printf(\"?? getopt returned character code 0%%o ??\\n\", c);\n"
           "            }\n"
           "        }\n"
           "\n"
           "        return optind;          /* Remaining non-options arguments are\n"
           "                                 * in [optind, argc).\n"
           "                                 */\n"
           "    }\n"
           "}\n"
           "\n"
           "    static void\n"
           "    fatal_free_opt(int rc)\n"
           "    {\n"
           "        if(options.output) free(options.output);\n"
           "        fatal(rc);\n"
           "    }\n"
           "\n");
}


static void instantiate_main(FILE *fp, const char *grammar)
{
   fprintf(fp,
           "\n\n"
           "%s_parser_t *%s_new_parser(const char *input_path,\n"
           "                                 char       *input_text,\n"
           "                                 unsigned    max_symbols"
           ");\n",
           grammar, grammar);

   fprintf(fp,
           "int\n"
           "main(int argc, char **argv)\n"
           "{\n"
           "    int         nl;\n"
           "    clock_t     start;\n"
           "    clock_t     end;\n"
           "    clock_t     thou;\n"
           "    clock_t     sec;\n"
           "    clock_t     nlps;\n"
           "    clock_t     t;\n"
           "    unsigned    iteration;\n"
           "    char *input_start;\n"
           "    FILE *output_fp;\n"
           "    %s_parser_t *parser;\n", grammar);

   fprintf(fp, "\n"
           "    get_options(argc, argv, &options);\n"
           "\n"
           "    if (options.output == 0) {\n"
           "       printf(\"--output option must be specified.\\n\");\n"
           "       fatal_free_opt(4);\n"
           "    }\n"
           "\n"
           "    if (optind >= argc) {\n"
           "        printf(\"No input file supplied.\\n\");\n"
           "        fatal_free_opt(5);\n"
           "    }\n"
           "\n"
           "    output_fp = fopen(options.output, \"w\");\n"
           "    if (output_fp == NULL) {\n"
           "        printf(\"Output file '%%s' cannot be opened for writing.\\n\",\n"
           "               options.output);\n"
           "        fatal_free_opt(6);\n"
           "    }\n"
           "\n");
   fprintf(fp,
           "    iteration = 0;\n"
           "    while (iteration < options.iterations) {\n"
           "        ++iteration;\n");
   fprintf(fp,
           "        input_start = read_input(argv[optind]);\n"
           "\n"
           "        parser = %s_new_parser(argv[optind], input_start, 100000);\n",
           grammar);
   fprintf(fp,
           "        printf(\"%%s parser.\\n\", parser->grammar);\n"
           "\n"
           "        start = clock();\n"
           "        nl    = parser->parse(output_fp);\n"
           "        end   = clock();\n"
           "        parser->term_parser();\n"
           "        if (nl <= 0) {\n"
           "            printf(\"\\nError in parse().\\n\");\n"
           "            delete parser;\n"
           "            delete [] input_start;\n"
           "            fclose(output_fp);\n"
           "            fatal_free_opt(8);\n"
           "        }\n"
           "\n"
           "        t = end - start;\n"
           "        if (t == 0) {\n"
           "            t = 1;\n"
           "        }\n"
           "\n"
           "        nlps = CLOCKS_PER_SEC * nl / t;\n"
           "        thou = t * 1000 / CLOCKS_PER_SEC;\n"
           "        sec  = thou / 1000;\n"
           "        thou -= sec * 1000;\n"
           "\n"
           "        printf(\"\\nSuccess ...\\n\");\n"
           "        printf(\"%%10s symbols in symbol table.\\n\",  number(parser->n_symbols));\n"
           "        printf(\"%%10s nodes in AST.\\n\",             number(parser->n_nodes));\n"
           "        printf(\"%%10s lines read in input file.\\n\", number(nl));\n"
           "        printf(\"%%10s lines per second.\\n\",         number(nlps));\n"
           "        printf(\"%%6ld.%%03ld seconds.\\n\",            sec, thou);\n"
           "\n"
           "        delete parser;\n"
           "        delete [] input_start;\n"
           "    }\n\n"
           "    fclose(output_fp);\n"
           "    if(options.output) free(options.output);\n"
           "    return 0;\n"
           "}\n"
           "\n");
}

static void user_main_cpp_fn(FILE       *fp,
                             const char *pathname,
                             const char *grammar,
                             const char *fname)
{
   fprintf(fp,
           "#include <assert.h>\n"
           "#include <fcntl.h>\n"
           "#include <getopt.h>\n"
           "#include <stdio.h>\n"
           "#include <stdlib.h>\n"
           "#include <string.h>\n"
           "#include <time.h>\n"
           "\n"
           "#include \"lrstar_basic_defs.h\"\n"
           "#include \"lrstar_sample.h\"\n"
           "#include \"%s_LexerTables_typedef.h\"\n"
           "#include \"%s_Parser.h\"\n"
           "\n\n", grammar, grammar);
   instantiate_getopt(fp);
   instantiate_main(fp, grammar);
}


void  PG_Main::GenerateOtherFiles ()
{
   callback_info.N_tacts    = N_tacts;
   callback_info.N_nacts    = N_nacts;
   callback_info.Tact_start = Tact_start;
   callback_info.Nact_start = Nact_start;

   write_file(gdn, gfn, NULL, "_Parser.h", true, parser_header_fn);
   write_file(gdn, gfn, NULL, "_Main.cpp", true, main_cpp_fn);
   write_file(gdn, gfn, NULL, "_user_main.cpp", true, user_main_cpp_fn);
   write_file(gdn, gfn, NULL, "_Parser.cpp", true, parser_cpp_fn);
   if (lrstar_linux) {
      write_file(gdn, gfn, NULL, "_user.cpp", true,
                 user_written_cpp_fn);
   }
   if (lrstar_linux) {
      write_file(gdn, gfn,  "Makefile", "", true, makefile_fn);
   } else {
      assert(lrstar_windows);
      write_file(gdn, gfn, "make.bat", "", true, make_bat_fn);
   }
}

///////////////////////////////////////////////////////////////////////////////////////////////////

void  PG_Main::nd_optimize()
{
   int i, j = 0, k, n, sum, lastterm;
   // COUNT NUMBER OF TERMINALS FOR NEW LIST ...
   n = 0;
   for (i = 0; i < N_states; i++)
   {
      lastterm = -1;
      if (nd_state[i] > 1) nd_state[i] = 1;
      for (j = nd_item[i]; j < nd_item[i + 1]; j++)
      {
         if (nd_term[j] != lastterm)
         {
            n++;
            lastterm = nd_term[j];
         }
      }
   }
   nd_start = new int[n + 1];
   n_ndterms = n;

   // CREATE NEW TERMINAL LIST AND START VECTOR ...
   n = 0;
   sum = 0;
   for (i = 0; i < N_states; i++)                  // For all states.
   {
      k = 0;                                       // Reset counter.
      lastterm = -1;                               // Reset to unknown.
      for (j = nd_item[i]; j < nd_item[i + 1]; j++)   // For all items in this state.
      {
         if (nd_term[j] != lastterm)   // Another terminal?
         {
            k++;                       // Count of terminals for this state.
            nd_start[n] = j;           // Start of actions for this terminal.
            lastterm = nd_term[j];  // Last terminal seen.
            nd_term[n++] = nd_term[j]; // Move terminal to new position.
         }
      }
      nd_item[i] = sum; // Change to new terminal start for this state.
      sum += k;
   }
   nd_start[n] = j;     // End of actions for last terminal.
   nd_item[i] = sum;   // End of new terminal list for last state.
}

///////////////////////////////////////////////////////////////////////////////

void  PG_Main::prt_prod (FILE* tables, int p, char* before, char* after)
{
   int t, s;
   fprintf (tables, "%s %s -> ", before, head_name[head_sym[p]]);
   for (t = F_tail[p]; t < F_tail[p+1]; t++)
   {
      s = Tail[t];
      if (s >= 0) fprintf (tables, "%s ", term_name[s]);
      else        fprintf (tables, "%s ", head_name[-s]);
   }
   fprintf (tables, "%s", after);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////

char* PG_Main::make_term (const char* s)
{
   static char string[256];
   if (*s == '\'' || *s == '\"')
   {
      int i =  0;
      char ch = *s;
      string[i++] = '\\';
      string[i++] = ch;
      for (const char* p = s+1; *(p+1) != 0; p++)
      {
         string[i++] = *p;
      }
      string[i++] = '\\';
      string[i++] = ch;
      string[i++] = 0;
   }
   else
   {
      int i =  0;
      for (const char* p = s; *p != 0; p++)
      {
         string[i++] = *p;
      }
      string[i++] = 0;
   }
   return (string);
}

//                                                                                               //
///////////////////////////////////////////////////////////////////////////////////////////////////



/* Local Variables:      */
/* mode: c               */
/* c-basic-offset: 3     */
/* tab-width: 3          */
/* indent-tabs-mode: nil */
/* End:                  */
