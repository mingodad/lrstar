/* Copyright 2018, 2023, 2024 Paul B Mann.  BSD License. */

#include <assert.h>
#include "CM_Global.h"
#include "LG_Global.h"
#include "LG_CreateTables.h"

enum {
   ts_TermNumb,
   ts_Tm,
   ts_Tr,
   ts_Tc,
   ts_N_ELEMENTS
};

struct data_types_t {           /* Tm, Tr, Tc, term_numb */
   const char *type;            /* C type, string form. */
   int         n_elem;          /* Number of elements in array. */
};
static data_types_t data_types[ts_N_ELEMENTS];


static const char *
namespace_indent(unsigned level)
{
   switch (level) {
   case 1:  return "    ";
   case 2:  return "        ";
   case 3:  return "            ";
   default: return "";          /* Unsupported depth. */
   }
}


static const char *
get_typestr(int *x, int n)
{
   int i, max = 0, min = 0;
   for (i = 0; i < n; i++)
   {
      if (x[i] > max) max = x[i];
      else if (x[i] < min) min = x[i];
   }
   if (min >= 0)
   {
      if      (max <=        127) return ("uint8"  ); // 1 byte
      else if (max <=        255) return ("uint8"  ); // 1 byte
      else if (max <=      32767) return ("uint16" ); // 2 bytes
      else if (max <=      65535) return ("uint16" ); // 2 bytes
      else if (max <= 2147483647) return ("uint32" ); // 4 bytes
      else                        return ("uint32" ); // 4 bytes
   }
   else if (max > -min)
   {
      if      (max <=        127) return ("int8"   ); // 1 byte
      else if (max <=      32767) return ("int16"  ); // 2 bytes
      else                        return ("int32"  ); // 4 bytes
   }
   else
   {
      if      (min >=       -127) return ("int8"   ); // 1 byte
      else if (min >=     -32767) return ("int16"  ); // 2 bytes
      else                        return ("int32"  ); // 4 bytes
   }
   return (""); // never gets here, avoid compiler error.
}



static size_t
filename_remaining(char       *s,
                   size_t      s_len) /* Elements in s. */
{
   // Returns number of bytes left in 's' for character storage.
   // Leaves 1 byte of space at the end for '\0'.

   size_t len = strlen(s);
   if (len < s_len) {
      return s_len - len - 1;
   } else {
      return 0;
   }
}


static void
create_filename(char       *dst,
                size_t      dst_len, /* Elements in dst. */
                const char *dname,   /* Directory. */
                const char *fname,   /* Filename base. */
                const char *cname,   /* Parser name. */
                const char *suffix,  /* Optional filename suffix. */
                const char *ext)     /* Extension. */
{
   strncpy(dst, dname, dst_len - 1);
   strncat(dst, fname, filename_remaining(dst, dst_len));
   strncat(dst, cname, filename_remaining(dst, dst_len));
   strncat(dst, suffix, filename_remaining(dst, dst_len));
   strncat(dst, ext, filename_remaining(dst, dst_len));
   dst[dst_len - 1] = '\0';
}


static void
lexer_inst(char *buf, size_t buf_len, const char *fname /* grammar name */)
{
   static const char *b[] = { "false", "true" };

   snprintf(buf, buf_len,
            "lexer_<%s, %s, %s, %s, %s>",
            b[!!optn[LG_DEBUG]],
            data_types[ts_TermNumb].type,
            data_types[ts_Tm].type,
            data_types[ts_Tr].type,
            data_types[ts_Tc].type);
}


static void
open_namespace(FILE *fp, const char *namespc)
{
   fprintf(fp, "namespace %s {\n", namespc);
}


static void
close_namespace(FILE *fp, const char *namespc)
{
   fprintf(fp, "\n};   /* namespace %s */\n", namespc);
}


static void open_guard(FILE *fp,
                       const char *fname,
                       const char *cname,
                       const char *ident)
{
   fprintf(fp, "// Generated by %s %s\n// DO NOT EDIT.\n\n", program, version);
   fprintf(fp,
           ("#if !defined(__%s_%s_%s)\n"
            "#define __%s_%s_%s\n\n"),
           fname, cname, ident,
           fname, cname, ident);
}

static void close_guard(FILE *fp)
{
   fprintf(fp, "\n#endif\n");
}


static void
extern_array(FILE *fp,
             const char *type_name,
             const char *var_name,
             unsigned    n_elem)
{
   fprintf(fp,
           "%sextern const %s %s[%d];  "
           "/* gcc can elide unreferenced constants. */\n",
           namespace_indent(1), type_name, var_name, n_elem);
}


static void
open_defn_array(FILE *fp,
                const char *comment,
                const char *type_name,
                const char *var_name,
                unsigned    n_elem)
{
   extern_array(fp, type_name, var_name, n_elem);
   fprintf(fp,
           "%sconst %s %s[%d] = {  /* %s */\n",
           namespace_indent(1), type_name, var_name, n_elem, comment);
}


static void
close_defn_array(FILE *fp, bool nl)
{
   if (nl) {
      fprintf(fp, "\n");
   }
   fprintf(fp, "%s};\n\n", namespace_indent(1));
}

void
LG::instantiate_lexer(const char *dname,
                      const char *fname,
                      const char *cname)
{
   FILE *fp;
   char pathname[PATH_MAX];

   create_filename(pathname, PATH_MAX, dname, fname, cname,
                   "", ".cpp");

   fp = fopen(pathname, "w");
   if (fp == NULL) {
      prt_log("Output file '%s' cannot be created.\n", pathname);
      Quit();
   }

   fprintf(fp,
           "#include \"lrstar_basic_defs.h\"\n"
           "#include \"lrstar_lexer.h\"\n"
           "#include \"%s_LexerTables_typedef.h\"\n\n", fname);

   if (optn [LG_DEBUG]) {
      fprintf(fp, "      #define DEBUG_LEXER\n");
   }
   fprintf(fp, "#define MAX    0x80000000\n\n");

   open_namespace(fp, fname);
   if (n_constants > 0) {
      int i;
      fprintf(fp, "enum terminal {\n");
      for (i = 0; i < n_constants-1; i++) {
         fprintf(fp, "   %s = %d,\n", Defcon_name[i], Defcon_value[i]);
      }
      fprintf(fp, "   %s = %d\n", Defcon_name[i], Defcon_value[i]);
      fprintf(fp, "};\n\n");
   }

   open_defn_array(fp,
                   "Terminal number.",
                   data_types[ts_TermNumb].type,
                   "lgr_term_numb",
                   N_states);

   for (int i = 0; i < N_states; i++) {
      if (i % 10 == 0) {
         fprintf(fp, "\n%s%5d, ", namespace_indent(2), D_red[i]);
      }
      else fprintf(fp, "%5d, ", D_red[i]);
   }
   close_defn_array(fp, true);

   open_defn_array(fp,
                   "Terminal transition matrix.",
                   data_types[ts_Tm].type,
                   "lgr_Tm",
                   T_size);
   for (int i = 0; i < T_size; i++) {
      if (i % 10 == 0) {
         if (T_matrix[i] == INT_MAX) {
            fprintf(fp, "\n%s%5s, ", namespace_indent(2), "  MAX");
         } else {
            fprintf(fp, "\n%s%5d, ", namespace_indent(2), T_matrix[i]);
         }
      } else {
         if (T_matrix[i] == INT_MAX) {
            fprintf(fp, "%5s, ", "  MAX");
         } else {
            fprintf(fp, "%5d, ", T_matrix[i]);
         }
      }
   }
   close_defn_array(fp, true);

   assert(optn[LG_TABL_MEDIUM]); /* Cannot set option; untested. */
   if (optn[LG_TABL_MEDIUM]) {
      open_defn_array(fp,
                      "Terminal transition matrix row.",
                      data_types[ts_Tr].type,
                      "lgr_Tr",
                      tt_states);
      for (int i = 0; i < tt_states; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n%s%5d, ", namespace_indent(2), T_row[i]);
         } else {
            fprintf(fp, "%5d, ", T_row[i]);
         }
      }
      close_defn_array(fp, true);
   } else {
      /* Non-existant Tr is handled in method Tr_() */
   }

   if (optn[LG_TABL_MEDIUM]) {
      open_defn_array(fp,
                      "Terminal transition matrix column.",
                      data_types[ts_Tc].type,
                      "lgr_Tc",
                      N_terms);
      for (int i = 0; i < N_terms; i++) {
         if (i % 10 == 0) {
            fprintf(fp, "\n%s%5d, ", namespace_indent(2), T_col[i]);
         } else {
            fprintf(fp, "%5d, ", T_col[i]);
         }
      }
      close_defn_array(fp, true);
   } else {
      /* Non-existant Tc is handled in method Tc_() */
   }
   close_namespace(fp, fname);
   fclose(fp);
}


static void
typedef_lexer(const char *dname,
              const char *fname,
              const char *cname,
              const char *lexer_instantiation)
{
   FILE *fp;
   char pathname[PATH_MAX];

   create_filename(pathname, PATH_MAX, dname, fname, cname,
                   "_typedef", ".h");

   fp = fopen(pathname, "w");
   if (fp == NULL) {
      prt_log("Output file '%s' cannot be created.\n", pathname);
      Quit();
   }

   open_guard(fp, fname, cname, "TYPEDEF");
   fprintf(fp, "#include \"lrstar_lexer.h\"\n\n");

   open_namespace(fp, fname);
   fprintf(fp,
           "%sextern const %s lgr_term_numb[%d];\n"
           "%sextern const %s lgr_Tm[%d];\n"
           "%sextern const %s lgr_Tr[%d];\n"
           "%sextern const %s lgr_Tc[%d];\n"
           "\n",
           namespace_indent(1),
           data_types[ts_TermNumb].type, data_types[ts_TermNumb].n_elem,
           namespace_indent(1),
           data_types[ts_Tm].type, data_types[ts_Tm].n_elem,
           namespace_indent(1),
           data_types[ts_Tr].type, data_types[ts_Tr].n_elem,
           namespace_indent(1),
           data_types[ts_Tc].type, data_types[ts_Tc].n_elem);
   /* Extend lrstar_lexer */
   fprintf(fp,
           "%stemplate<bool C_debug, typename T_term_numb, "
           "typename T_Tm, typename T_Tr, typename T_Tc>\n"
           "%sclass lexer_ : public lrstar_lexer<C_debug, T_term_numb, "
           "T_Tm, T_Tr, T_Tc>\n"
           "%s{\n", namespace_indent(1),
           namespace_indent(1), namespace_indent(1));

   /* Cannot set option; untested.
    *
    * If LG_TABL_MEDIUM is not set, one or more of the matrices may
    * not be created.  In this case, the pointers should be set to
    * NULL.  Refer to the places where the matrices are generated to
    * see the conditions, and then update the code below accordingly.
    */
   assert(optn[LG_TABL_MEDIUM]);
   fprintf(fp,
           "%spublic:\n"
           "%slexer_(char *input_start) :\n"
           "%slrstar_lexer<C_debug, T_term_numb, "
           "T_Tm, T_Tr, T_Tc>(&lgr_term_numb[0], &lgr_Tm[0], "
           "&lgr_Tr[0], &lgr_Tc[0], input_start)\n"
           "%s{\n"
           "%s}\n",
           namespace_indent(1),
           namespace_indent(2),
           namespace_indent(3),
           namespace_indent(2),
           namespace_indent(2));
   fprintf(fp,
           "%s};\n\n", namespace_indent(1));


   fprintf(fp, "%stypedef %s lexer_t;\n", namespace_indent(1),
           lexer_instantiation);
   close_namespace(fp, fname);
   close_guard(fp);
   fclose(fp);
}


void LG::GenerateLexerDefines ()
{
   const char *lexer_class = "_LexerTables";
   char        lexer[PATH_MAX + 128];

   // T_matrix ...

   data_types[ts_Tm].type   = get_typestr (T_matrix, T_size);
   data_types[ts_Tm].n_elem = T_size;

   // T_matrix row ...
   assert(optn[LG_TABL_MEDIUM]); /* Cannot set option; untested. */
   if (optn[LG_TABL_MEDIUM])
   {
      data_types[ts_Tr].type = get_typestr (T_row, tt_states);
      data_types[ts_Tr].n_elem = tt_states;
   }

   // T_matrix column ...
   if (optn[LG_TABL_MEDIUM])
   {
      data_types[ts_Tc].type = get_typestr (T_col, N_terms);
      data_types[ts_Tc].n_elem = N_terms;
   }

   // Terminal Numbers (one for for each state) ...
   if (optn[LG_TABL_MEDIUM])
   {
      data_types[ts_TermNumb].type = get_typestr (D_red, N_states);
      data_types[ts_TermNumb].n_elem = N_states;
   }

   LG::instantiate_lexer(gdn, gfn, "_Lexer");
   lexer_inst(lexer, sizeof(lexer) / sizeof(lexer[0]), gfn);
   typedef_lexer(gdn, gfn, lexer_class, lexer);
}

/* Local Variables:      */
/* mode: c               */
/* c-basic-offset: 3     */
/* tab-width: 3          */
/* indent-tabs-mode: nil */
/* End:                  */
