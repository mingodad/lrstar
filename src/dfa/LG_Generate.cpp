/* Copyright 2018, 2023 Paul B Mann.  BSD License. */

#include "CM_Global.h"
#include "LG_Global.h"
#include "LG_CreateTables.h"

enum {
   ts_TermNumb,
   ts_Tm,
   ts_Tr,
   ts_Tc,
   ts_N_ELEMENTS
} type_sizes;

struct data_types_t {           /* Tm, Tr, Tc, term_numb */
   const char *type;            /* C type, string form. */
   int         n_elem;          /* Number of elements in array. */
};
static data_types_t data_types[ts_N_ELEMENTS];


static const char *
get_typestr(int *x, int n)
{
   int i, max = 0, min = 0;
   for (i = 0; i < n; i++)
   {
      if (x[i] > max) max = x[i];
      else if (x[i] < min) min = x[i];
   }
   if (min >= 0)
   {
      if      (max <=        127) return ("uint8"  ); // 1 byte
      else if (max <=        255) return ("uint8"  ); // 1 byte
      else if (max <=      32767) return ("uint16" ); // 2 bytes
      else if (max <=      65535) return ("uint16" ); // 2 bytes
      else if (max <= 2147483647) return ("uint32" ); // 4 bytes
      else                        return ("uint32" ); // 4 bytes
   }
   else if (max > -min)
   {
      if      (max <=        127) return ("int8"   ); // 1 byte
      else if (max <=      32767) return ("int16"  ); // 2 bytes
      else                        return ("int32"  ); // 4 bytes
   }
   else
   {
      if      (min >=       -127) return ("int8"   ); // 1 byte
      else if (min >=     -32767) return ("int16"  ); // 2 bytes
      else                        return ("int32"  ); // 4 bytes
   }
   return (""); // never gets here, avoid compiler error.
}



static size_t
filename_remaining(char       *s,
                   size_t      s_len) /* Elements in s. */
{
   // Returns number of bytes left in 's' for character storage.
   // Leaves 1 byte of space at the end for '\0'.

   size_t len = strlen(s);
   if (len < s_len) {
      return s_len - len - 1;
   } else {
      return 0;
   }
}


static void
create_filename(char       *dst,
                size_t      dst_len, /* Elements in dst. */
                const char *dname,   /* Directory. */
                const char *fname,   /* Filename base. */
                const char *cname,   /* Parser name. */
                const char *suffix,  /* Optional filename suffix. */
                const char *ext)     /* Extension. */
{
   strncpy(dst, dname, dst_len - 1);
   strncat(dst, fname, filename_remaining(dst, dst_len));
   strncat(dst, cname, filename_remaining(dst, dst_len));
   strncat(dst, suffix, filename_remaining(dst, dst_len));
   strncat(dst, ext, filename_remaining(dst, dst_len));
   dst[dst_len - 1] = '\0';
}


static const char *
template_decl(void)
{
   static const char *decl = ("template<typename T_term_numb, "
                              "typename T_Tm, "
                              "typename T_Tr, "
                              "typename T_Tc>");
   return decl;
}


static const char *
lexer_decl(void)
{
   static const char *inst = ("templ_lrstar_lexer<T_term_numb, "
                              "T_Tm, T_Tr, T_Tc>");
   return inst;
}


static void
lexer_inst(char *buf, size_t buf_len)
{
   snprintf(buf, buf_len,
            "templ_lrstar_lexer<%s, %s, %s, %s>",
            data_types[ts_TermNumb].type,
            data_types[ts_Tm].type,
            data_types[ts_Tr].type,
            data_types[ts_Tc].type);
}



static void open_guard(FILE *fp,
                       const char *fname,
                       const char *cname,
                       const char *ident)
{
   fprintf(fp, "// Generated by %s %s)\n// DO NOT EDIT.\n\n", program, version);
   fprintf(fp,
           ("#if !defined(__%s_%s_%s)\n"
            "#define __%s_%s_%s\n\n"),
           fname, cname, ident,
           fname, cname, ident);
}

static void close_guard(FILE *fp)
{
   fprintf(fp, "\n#endif\n");
}


static void
instantiate_lexer(const char *dname,
                  const char *fname,
                  const char *cname,
                  const char *lexer_instantiation)
{
   FILE *fp;
   char pathname[PATH_MAX];

   create_filename(pathname, PATH_MAX, dname, fname, cname,
                   "_instantiate", ".h");

   fp = fopen(pathname, "w");
   if (fp == NULL) {
      prt_log("Output file '%s' cannot be created.\n", pathname);
      Quit();
   }

   open_guard(fp, fname, cname, "INSTANTIATE");
   fprintf(fp, "// Include this file only once in a project.  It instantiates a "
           "lexer.\n");

   fprintf(fp, ("%s\n"
                "const int %s::n_term_numb = %d;\n\n"
                ""), template_decl(), lexer_decl(), data_types[ts_TermNumb].n_elem);
   fprintf(fp, ("%s\n"
                "const int %s::n_Tm = %d;\n\n"
                ""), template_decl(), lexer_decl(), data_types[ts_Tm].n_elem);
   fprintf(fp, ("%s\n"
                "const int %s::n_Tr = %d;\n\n"
                ""), template_decl(), lexer_decl(), data_types[ts_Tr].n_elem);
   fprintf(fp, ("%s\n"
                "const int %s::n_Tc = %d;\n\n"
                ""), template_decl(), lexer_decl(), data_types[ts_Tc].n_elem);

   fprintf(fp, ("%s\n"
                "const T_term_numb *%s::term_numb = &term_numb_[0];\n\n"
                ""), template_decl(), lexer_decl());
   fprintf(fp, ("%s\n"
                "const T_Tm *%s::Tm = &Tm_[0];\n\n"
                ""), template_decl(), lexer_decl());
   fprintf(fp, ("%s\n"
                "const T_Tr *%s::Tr = &Tr_[0];\n\n"
                ""), template_decl(), lexer_decl());
   fprintf(fp, ("%s\n"
                "const T_Tc *%s::Tc = &Tc_[0];\n\n"
                ""), template_decl(), lexer_decl());

   fprintf(fp, ("%s\n"
                "Token %s::token;\n\n"), template_decl(), lexer_decl());

   fprintf(fp, ("%s\n"
                "Token %s::lookahead;\n\n"), template_decl(), lexer_decl());

   fprintf(fp, ("%s\n"
                "int %s::tab;\n\n"), template_decl(), lexer_decl());

   fprintf(fp, ("%s\n"
                "int %s::linenumb;\n\n"), template_decl(), lexer_decl());

   fprintf(fp, ("%s\n"
                "int %s::linenumb_printed;\n\n"), template_decl(), lexer_decl());

   fprintf(fp, ("%s\n"
                "int %s::lookahead_linenumb;\n\n"), template_decl(), lexer_decl());

   fprintf(fp, "template class %s;\n", lexer_instantiation);
   close_guard(fp);
   fclose(fp);
}


static void
typedef_lexer(const char *dname,
              const char *fname,
              const char *cname,
              const char *lexer_instantiation)
{
   FILE *fp;
   char pathname[PATH_MAX];

   create_filename(pathname, PATH_MAX, dname, fname, cname,
                   "_typedef", ".h");

   fp = fopen(pathname, "w");
   if (fp == NULL) {
      prt_log("Output file '%s' cannot be created.\n", pathname);
      Quit();
   }

   open_guard(fp, fname, cname, "TYPEDEF");
   fprintf(fp, "#include \"lrstar_lexer.h\"\n");
   fprintf(fp, "typedef %s lexer_t;\n", lexer_instantiation);
   close_guard(fp);
   fclose(fp);
}


static void
generate_lexer(const char *dname,
               const char *fname,
               const char *cname)
{
   char lexer_instantiation[128];

   lexer_inst(lexer_instantiation, 128);
   instantiate_lexer(dname, fname, cname, lexer_instantiation);
   typedef_lexer(dname, fname, cname, lexer_instantiation);

}


void LG::GenerateLexerDefines ()
{
   FILE       *tables;
   FILE       *header;
   char        filename_hpp[PATH_MAX];
   char        filename_h[PATH_MAX];
   const char *lexer_class = "_LexerTables";

   create_filename(filename_h, PATH_MAX, gdn, gfn, lexer_class, "", ".h");

   if (chmod (filename_h, S_IWRITE) == 0) // File can be written ?
   {
      if (unlink (filename_h) != 0) // Delete it?
      {
         if (++n_errors == 1) prt_log ("\n");
         prt_log ("Output file '%s' cannot be written!\n", filename_h);
         Quit();
      }
   }

   header = fopen (filename_h, "w");
   if (header == NULL)
   {
      if (++n_errors == 1) prt_log ("\n");
      prt_log ("Output file '%s' cannot be written!\n", filename_h);
      Quit();
   }
   prt_logonly ("Generating: %s\n", filename_h);

   fprintf (header, "\n");
   fprintf (header, "////////////////////////////////////////////////////////////////////////////////\n");
   fprintf (header, "//\n");
   fprintf (header, "//    %s (generated by %s %s)\n", filename_h, program, version);
   fprintf (header, "\n");

   fprintf (header, "      #pragma once\n\n");

   fprintf (header, "      #undef  DEBUG_LEXER\n\n");    // In case of multiple lexers.

   if (optn [LG_DEBUG]) fprintf (header, "      #define DEBUG_LEXER\n");

   fprintf (header, "\n/*\n");

   create_filename(filename_hpp, PATH_MAX, gdn, gfn, lexer_class, "", ".hpp");

   if (chmod (filename_hpp, S_IWRITE) == 0) // File can be written ?
   {
      if (unlink (filename_hpp) != 0) // Delete it?
      {
         if (++n_errors == 1) prt_log ("\n");
         prt_log ("Output file '%s' cannot be written!\n", filename_hpp);
         Quit();
      }
   }

   tables = fopen (filename_hpp, "w");
   if (tables == NULL)
   {
      if (++n_errors == 1) prt_log ("\n");
      prt_log ("Output file '%s' cannot be written!\n", filename_hpp);
      Quit();
   }
   prt_logonly ("Generating: %s\n\n", filename_hpp);

   fprintf (tables, "\n");
   fprintf (tables, "////////////////////////////////////////////////////////////////////////////////////////////////////\n");
   fprintf (tables, "//\n");
   fprintf (tables, "//    %s (generated by %s %s)\n\n", filename_hpp, program, version);

   if (lrstar_windows) {
      fprintf (tables, "      #define uint   unsigned int\n");
      fprintf (tables, "      #define uchar  unsigned char\n");
      fprintf (tables, "      #define ushort unsigned short\n");
   }
   fprintf (tables, "      #define MAX    0x80000000\n\n");

   // T_matrix ...

   data_types[ts_Tm].type   = get_typestr (T_matrix, T_size);
   data_types[ts_Tm].n_elem = T_size;
   fprintf (header, "      static const %-6s Tm_[%6d]        ; "
            "// Terminal transition matrix.\n",
            data_types[ts_Tm].type, T_size);
   fprintf (tables, "   // Terminal transition matrix ...\n");
   fprintf (tables, "      static const %s Tm_[%d] = \n",
            data_types[ts_Tm].type, T_size);
   fprintf (tables, "      {");
   for (int i = 0; i < T_size; i++)
   {
      if (i % 20 == 0)
      {
         if (i > 0) fprintf (tables, ",");
         if (T_matrix[i] == INT_MAX)
            fprintf (tables, "\n      %5s", "  MAX");
         else fprintf (tables, "\n      %5d", T_matrix[i]);
      }
      else
      {
         if (T_matrix[i] == INT_MAX)
            fprintf (tables, ",%5s", "  MAX");
         else fprintf (tables, ",%5d", T_matrix[i]);
      }
   }
   fprintf (tables, "\n      };\n\n");

   // T_matrix row ...
   if (optn[LG_TABL_MEDIUM])
   {
      data_types[ts_Tr].type = get_typestr (T_row, tt_states);
      data_types[ts_Tr].n_elem = tt_states;
      fprintf (header, "      static const %-6s Tr_[%6d]        ; "
               "// Terminal transition matrix row.\n",
               data_types[ts_Tr].type, tt_states);
      fprintf (tables, "   // Terminal transition matrix row ...\n");
      fprintf (tables, "      static const %s Tr_[%d] = \n",
               data_types[ts_Tr].type, tt_states);
      fprintf (tables, "      {");
      for (int i = 0; i < tt_states; i++)
      {
         if (i % 20 == 0)
         {
            if (i > 0) fprintf (tables, ",");
            fprintf (tables, "\n      %5d", T_row[i]);
         }
         else fprintf (tables, ",%5d", T_row[i]);
      }
      fprintf (tables, "\n      };\n\n");
   }

   // T_matrix column ...
   if (optn[LG_TABL_MEDIUM])
   {
      data_types[ts_Tc].type = get_typestr (T_col, N_terms);
      data_types[ts_Tc].n_elem = N_terms;
      fprintf (header, "      static const %-6s Tc_[%6d]        ; "
               "// Terminal transition matrix column.\n",
               data_types[ts_Tc].type, N_terms);
      fprintf (tables, "   // Terminal transition matrix column ...\n");
      fprintf (tables, "      static const %s Tc_[%d] = \n",
               data_types[ts_Tc].type, N_terms);
      fprintf (tables, "      {");
      for (int i = 0; i < N_terms; i++)
      {
         if (i % 20 == 0)
         {
            if (i > 0) fprintf (tables, ",");
            fprintf (tables, "\n      %5d", T_col[i]);
         }
         else fprintf (tables, ",%5d", T_col[i]);
      }
      fprintf (tables, "\n      };\n\n");
   }

   // Terminal Numbers (one for for each state) ...
   if (optn[LG_TABL_MEDIUM])
   {
      data_types[ts_TermNumb].type = get_typestr (D_red, N_states);
      data_types[ts_TermNumb].n_elem = N_states;
      fprintf (header, "      static const %-6s term_numb_[%6d] ; "
               "// Terminal number.\n",
               data_types[ts_TermNumb].type, N_states);
      fprintf (tables, "   // Terminal number ...\n");
      fprintf (tables, "      static const %s term_numb_[%d] = \n",
               data_types[ts_TermNumb].type, N_states);
      fprintf (tables, "      {");
      for (int i = 0; i < N_states; i++)
      {
         if (i % 20 == 0)
         {
            if (i > 0) fprintf (tables, ",");
            fprintf (tables, "\n      %5d", D_red[i]);
         }
         else fprintf (tables, ",%5d", D_red[i]);
      }
      fprintf (tables, "\n      };\n\n");
   }

   fprintf (tables, "#include \"%s_LexerTables_instantiate.h\"\n", gfn);

   fprintf (tables, "//\n");
   fprintf (tables, "////////////////////////////////////////////////////////////////////////////////////////////////////\n");
   fprintf (tables, "\n");

   generate_lexer(gdn, gfn, lexer_class);

   fclose (tables);
   chmod (filename_hpp, S_IREAD); // Make output file read-only.

   fprintf (header, "*/\n\n");
   if (n_constants > 0)
   {
      int i;
      fprintf (header,
               "      enum terminal\n"
               "      {\n");
      for (i = 0; i < n_constants-1; i++)
      {
         fprintf (header, "         %s = %d,\n", Defcon_name[i], Defcon_value[i]);
      }
      fprintf (header, "         %s = %d\n", Defcon_name[i], Defcon_value[i]);
      fprintf (header,
               "      };\n\n");
   }

   fprintf (header, "//\n");
   fprintf (header, "////////////////////////////////////////////////////////////////////////////////\n");

   fclose (header);
   chmod (filename_h, S_IREAD); // Make output file read-only.
}

//                                                                                                 //
/////////////////////////////////////////////////////////////////////////////////////////////////////
/* Local Variables:      */
/* mode: c               */
/* c-basic-offset: 3     */
/* tab-width: 3          */
/* indent-tabs-mode: nil */
/* End:                  */
